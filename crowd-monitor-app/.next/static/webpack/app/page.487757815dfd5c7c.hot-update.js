"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./lib/mockData.ts":
/*!*************************!*\
  !*** ./lib/mockData.ts ***!
  \*************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   generateRoutingAlert: function() { return /* binding */ generateRoutingAlert; },\n/* harmony export */   initializeCrowdSimulation: function() { return /* binding */ initializeCrowdSimulation; },\n/* harmony export */   simulateCrowdData: function() { return /* binding */ simulateCrowdData; },\n/* harmony export */   simulateHallData: function() { return /* binding */ simulateHallData; },\n/* harmony export */   updateCrowdPositions: function() { return /* binding */ updateCrowdPositions; }\n/* harmony export */ });\n// Simulate realistic crowd data for the 4 gates\nfunction simulateCrowdData() {\n    const baseTime = Date.now();\n    // Create realistic variations in crowd levels\n    const variation1 = Math.sin(baseTime / 10000) * 20 + Math.random() * 10;\n    const variation2 = Math.cos(baseTime / 8000) * 30 + Math.random() * 15;\n    const variation3 = Math.sin(baseTime / 12000) * 25 + Math.random() * 12;\n    const variation4 = Math.cos(baseTime / 15000) * 18 + Math.random() * 8;\n    const gates = [\n        createGate(1, \"40.7495,-73.9685\", 45 + Math.round(variation1)),\n        createGate(2, \"40.7485,-73.9675\", 230 + Math.round(variation2)),\n        createGate(3, \"40.7483,-73.9695\", 125 + Math.round(variation3)),\n        createGate(4, \"40.7493,-73.9665\", 112 + Math.round(variation4))\n    ];\n    return gates;\n}\n// Simulate hall data\nfunction simulateHallData() {\n    const baseTime = Date.now();\n    const halls = [\n        createHall(1, Math.round(180 + Math.sin(baseTime / 5000) * 50)),\n        createHall(2, Math.round(320 + Math.cos(baseTime / 6000) * 80)),\n        createHall(3, Math.round(150 + Math.sin(baseTime / 7000) * 40)),\n        createHall(4, Math.round(280 + Math.cos(baseTime / 8000) * 60))\n    ];\n    return halls;\n}\nfunction createHall(hallNumber, count) {\n    const capacity = 400;\n    const densityPercent = count / capacity * 100;\n    let crowdLevel;\n    let heatmapColor;\n    let stampede_risk;\n    if (densityPercent < 40) {\n        crowdLevel = \"low\";\n        heatmapColor = \"#10b981\";\n        stampede_risk = \"low\";\n    } else if (densityPercent < 60) {\n        crowdLevel = \"medium\";\n        heatmapColor = \"#f59e0b\";\n        stampede_risk = \"low\";\n    } else if (densityPercent < 80) {\n        crowdLevel = \"high\";\n        heatmapColor = \"#f97316\";\n        stampede_risk = \"medium\";\n    } else {\n        crowdLevel = \"critical\";\n        heatmapColor = \"#ef4444\";\n        stampede_risk = \"high\";\n    }\n    return {\n        id: \"hall-\".concat(hallNumber),\n        number: hallNumber,\n        name: \"Hall \".concat(hallNumber),\n        capacity,\n        current_count: count,\n        density_percent: parseFloat(densityPercent.toFixed(1)),\n        crowd_level: crowdLevel,\n        heatmap_color: heatmapColor,\n        stampede_risk\n    };\n}\n// Initialize crowd simulation with people\nfunction initializeCrowdSimulation() {\n    let hallCount = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 4;\n    const people = [];\n    const totalPeople = 800; // Increased for better visuals\n    for(let i = 0; i < totalPeople; i++){\n        const hall = Math.floor(Math.random() * hallCount) + 1;\n        const targetExit = Math.floor(Math.random() * 4) + 1;\n        // Position within hall bounds (random start)\n        const { minX, maxX, minY, maxY } = getHallBounds(hall);\n        // Random position inside hall\n        const x = minX + Math.random() * (maxX - minX);\n        const y = minY + Math.random() * (maxY - minY);\n        people.push({\n            id: \"person-\".concat(i),\n            x,\n            y,\n            vx: 0,\n            vy: 0,\n            hall,\n            targetExit,\n            speed: 0.8 + Math.random() * 0.6,\n            status: \"in_hall\",\n            targetX: x,\n            targetY: y\n        });\n    }\n    return people;\n}\n// Update crowd positions for structured movement\nfunction updateCrowdPositions(people) {\n    return people.map((person)=>{\n        let { x, y, status, targetX, targetY, hall, targetExit, speed } = person;\n        // State Machine for Movement\n        // 1. IN HALL: Move towards hall exit (connection to corridor)\n        if (status === \"in_hall\") {\n            // Get hall exit point (approximate center of inner wall)\n            const hallExit = getHallExitPoint(hall);\n            // Set target to hall exit\n            targetX = hallExit.x;\n            targetY = hallExit.y;\n            // Check if reached hall exit\n            if (getDistance(x, y, targetX, targetY) < 20) {\n                status = \"to_corridor\";\n            }\n        } else if (status === \"to_corridor\") {\n            // Target is the central corridor intersection or lane entry\n            // Simple logic: move towards center coordinates based on hall\n            if (hall === 1 || hall === 3) targetX = 390; // Move right to vertical corridor\n            else targetX = 410; // Move left to vertical corridor\n            if (hall === 1 || hall === 2) targetY = 390; // Move down to horizontal\n            else targetY = 410; // Move up to horizontal\n            // Once in corridor bounds, switch to lane movement\n            if (x > 380 && x < 420 || y > 380 && y < 420) {\n                status = \"in_lane\";\n            }\n        } else if (status === \"in_lane\") {\n            const exitPoint = getExitPoint(targetExit);\n            targetX = exitPoint.x;\n            targetY = exitPoint.y;\n            // If close to exit, switch to accumulating\n            if (getDistance(x, y, targetX, targetY) < 40) {\n                status = \"at_exit\";\n            }\n        } else if (status === \"at_exit\") {\n            // Just wiggle around the exit point to simulate crowding\n            const exitPoint = getExitPoint(targetExit);\n            targetX = exitPoint.x + (Math.random() - 0.5) * 30;\n            targetY = exitPoint.y + (Math.random() - 0.5) * 30;\n        }\n        // Calculate velocity vector towards target\n        const dx = targetX - x;\n        const dy = targetY - y;\n        const dist = Math.sqrt(dx * dx + dy * dy);\n        let vx = 0, vy = 0;\n        if (dist > 1) {\n            vx = dx / dist * speed;\n            vy = dy / dist * speed;\n        }\n        // Add some \"human\" randomness/wiggle\n        vx += (Math.random() - 0.5) * 0.2;\n        vy += (Math.random() - 0.5) * 0.2;\n        return {\n            ...person,\n            x: x + vx,\n            y: y + vy,\n            vx,\n            vy,\n            status,\n            targetX,\n            targetY\n        };\n    });\n}\n// Helpers\nfunction getHallBounds(hall) {\n    if (hall === 1) return {\n        minX: 120,\n        maxX: 360,\n        minY: 120,\n        maxY: 360\n    };\n    if (hall === 2) return {\n        minX: 440,\n        maxX: 680,\n        minY: 120,\n        maxY: 360\n    };\n    if (hall === 3) return {\n        minX: 120,\n        maxX: 360,\n        minY: 440,\n        maxY: 680\n    };\n    return {\n        minX: 440,\n        maxX: 680,\n        minY: 440,\n        maxY: 680\n    };\n}\nfunction getHallExitPoint(hall) {\n    // Returns the point where hall connects to corridor\n    if (hall === 1) return {\n        x: 370,\n        y: 370\n    }; // Bottom-right of Hall 1\n    if (hall === 2) return {\n        x: 430,\n        y: 370\n    }; // Bottom-left of Hall 2\n    if (hall === 3) return {\n        x: 370,\n        y: 430\n    }; // Top-right of Hall 3\n    return {\n        x: 430,\n        y: 430\n    }; // Top-left of Hall 4\n}\nfunction getExitPoint(exit) {\n    if (exit === 1) return {\n        x: 400,\n        y: 30\n    }; // Top\n    if (exit === 2) return {\n        x: 770,\n        y: 400\n    }; // Right\n    if (exit === 3) return {\n        x: 400,\n        y: 770\n    }; // Bottom\n    return {\n        x: 30,\n        y: 400\n    }; // Left\n}\nfunction getDistance(x1, y1, x2, y2) {\n    return Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));\n}\n// Generate dynamic routing alerts\nfunction generateRoutingAlert(gates, halls) {\n    const bestGate = gates.reduce((best, current)=>current.metrics.wait_time_seconds < best.metrics.wait_time_seconds ? current : best);\n    const worstGate = gates.reduce((worst, current)=>current.metrics.wait_time_seconds > worst.metrics.wait_time_seconds ? current : worst);\n    // Check for high-risk halls\n    const highRiskHalls = halls.filter((h)=>h.stampede_risk === \"high\" || h.stampede_risk === \"critical\");\n    if (highRiskHalls.length > 0) {\n        return {\n            id: \"alert-\".concat(Date.now()),\n            type: \"stampede\",\n            severity: \"critical\",\n            message: \"⚠️ High stampede risk in \".concat(highRiskHalls.map((h)=>h.name).join(\", \"), \"! Avoid these areas.\"),\n            suggestedExit: bestGate.gate_number,\n            timestamp: Date.now(),\n            active: true\n        };\n    }\n    if (worstGate.crowd_level === \"critical\" && bestGate.crowd_level === \"low\") {\n        return {\n            id: \"alert-\".concat(Date.now()),\n            type: \"routing\",\n            severity: \"high\",\n            message: \"\\uD83D\\uDEA8 Exit \".concat(worstGate.gate_number, \" is overcrowded! Use Exit \").concat(bestGate.gate_number, \" instead (\").concat(bestGate.metrics.wait_time_formatted, \" wait).\"),\n            suggestedExit: bestGate.gate_number,\n            timestamp: Date.now(),\n            active: true\n        };\n    }\n    if (worstGate.crowd_level === \"high\" && bestGate.crowd_level === \"low\") {\n        return {\n            id: \"alert-\".concat(Date.now()),\n            type: \"routing\",\n            severity: \"medium\",\n            message: \"\\uD83D\\uDCA1 Exit \".concat(bestGate.gate_number, \" has the shortest wait time (\").concat(bestGate.metrics.wait_time_formatted, \").\"),\n            suggestedExit: bestGate.gate_number,\n            timestamp: Date.now(),\n            active: true\n        };\n    }\n    return null;\n}\nfunction createGate(gateNumber, coordinates, count) {\n    const [lat, lon] = coordinates.split(\",\").map(Number);\n    // Determine crowd level\n    let crowdLevel;\n    let crowdColor;\n    if (count < 80) {\n        crowdLevel = \"low\";\n        crowdColor = \"#10b981\";\n    } else if (count < 150) {\n        crowdLevel = \"medium\";\n        crowdColor = \"#f59e0b\";\n    } else if (count < 220) {\n        crowdLevel = \"high\";\n        crowdColor = \"#f97316\";\n    } else {\n        crowdLevel = \"critical\";\n        crowdColor = \"#ef4444\";\n    }\n    // Calculate metrics\n    const density = count / 200;\n    const waitTime = Math.max(30, count * 2);\n    const queueLength = count * 0.08;\n    // Generate trend\n    const sparkline = generateSparkline(count);\n    const trend = determineTrend(sparkline);\n    // Gate names\n    const gateNames = [\n        \"North Exit (Exit 1)\",\n        \"East Exit (Exit 2)\",\n        \"South Exit (Exit 3)\",\n        \"West Exit (Exit 4)\"\n    ];\n    return {\n        id: \"gate-\".concat(gateNumber),\n        gate_number: gateNumber,\n        name: gateNames[gateNumber - 1],\n        location: {\n            lat,\n            lon\n        },\n        status: \"active\",\n        crowd_level: crowdLevel,\n        crowd_color: crowdColor,\n        metrics: {\n            people_count: count,\n            density: parseFloat(density.toFixed(2)),\n            density_level: crowdLevel,\n            wait_time_seconds: waitTime,\n            wait_time_formatted: formatWaitTime(waitTime),\n            queue_length_meters: parseFloat(queueLength.toFixed(1))\n        },\n        trend,\n        prediction: {\n            \"5_min_ahead\": {\n                count: Math.round(count * (1 + (Math.random() - 0.4) * 0.2)),\n                confidence: 0.85 + Math.random() * 0.1\n            },\n            \"10_min_ahead\": {\n                count: Math.round(count * (1 + (Math.random() - 0.4) * 0.3)),\n                confidence: 0.75 + Math.random() * 0.1\n            }\n        },\n        has_accessibility: gateNumber === 1 || gateNumber === 3,\n        efficiency_percent: Math.round(70 + Math.random() * 25)\n    };\n}\nfunction generateSparkline(currentCount) {\n    const points = 10;\n    const sparkline = [];\n    let value = currentCount - 20;\n    for(let i = 0; i < points; i++){\n        value += (Math.random() - 0.5) * 10;\n        value = Math.max(20, Math.min(300, value));\n        sparkline.push(Math.round(value));\n    }\n    sparkline[sparkline.length - 1] = currentCount;\n    return sparkline;\n}\nfunction determineTrend(sparkline) {\n    const first = sparkline[0];\n    const last = sparkline[sparkline.length - 1];\n    const change = (last - first) / first * 100;\n    let direction;\n    if (change > 10) {\n        direction = \"increasing\";\n    } else if (change < -10) {\n        direction = \"decreasing\";\n    } else {\n        direction = \"stable\";\n    }\n    return {\n        direction,\n        change_percent: parseFloat(Math.abs(change).toFixed(1)),\n        sparkline\n    };\n}\nfunction formatWaitTime(seconds) {\n    const minutes = Math.round(seconds / 60);\n    if (minutes === 0) return \"<1 minute\";\n    if (minutes === 1) return \"1 minute\";\n    return \"\".concat(minutes, \" minutes\");\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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SCxVQUFVO0lBQ3JDLElBQUlDLFlBQVksR0FBRyxPQUFPO0lBQzFCLElBQUlBLFlBQVksR0FBRyxPQUFPO0lBQzFCLE9BQU8sR0FBVyxPQUFSQSxTQUFRO0FBQ3RCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2xpYi9tb2NrRGF0YS50cz80NzQyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEdhdGUsIEhhbGwsIENyb3dkUGVyc29uLCBBbGVydCB9IGZyb20gJ0AvdHlwZXMnO1xyXG5cclxuLy8gU2ltdWxhdGUgcmVhbGlzdGljIGNyb3dkIGRhdGEgZm9yIHRoZSA0IGdhdGVzXHJcbmV4cG9ydCBmdW5jdGlvbiBzaW11bGF0ZUNyb3dkRGF0YSgpOiBHYXRlW10ge1xyXG4gICAgY29uc3QgYmFzZVRpbWUgPSBEYXRlLm5vdygpO1xyXG5cclxuICAgIC8vIENyZWF0ZSByZWFsaXN0aWMgdmFyaWF0aW9ucyBpbiBjcm93ZCBsZXZlbHNcclxuICAgIGNvbnN0IHZhcmlhdGlvbjEgPSBNYXRoLnNpbihiYXNlVGltZSAvIDEwMDAwKSAqIDIwICsgTWF0aC5yYW5kb20oKSAqIDEwO1xyXG4gICAgY29uc3QgdmFyaWF0aW9uMiA9IE1hdGguY29zKGJhc2VUaW1lIC8gODAwMCkgKiAzMCArIE1hdGgucmFuZG9tKCkgKiAxNTtcclxuICAgIGNvbnN0IHZhcmlhdGlvbjMgPSBNYXRoLnNpbihiYXNlVGltZSAvIDEyMDAwKSAqIDI1ICsgTWF0aC5yYW5kb20oKSAqIDEyO1xyXG4gICAgY29uc3QgdmFyaWF0aW9uNCA9IE1hdGguY29zKGJhc2VUaW1lIC8gMTUwMDApICogMTggKyBNYXRoLnJhbmRvbSgpICogODtcclxuXHJcbiAgICBjb25zdCBnYXRlczogR2F0ZVtdID0gW1xyXG4gICAgICAgIGNyZWF0ZUdhdGUoMSwgJzQwLjc0OTUsLTczLjk2ODUnLCA0NSArIE1hdGgucm91bmQodmFyaWF0aW9uMSkpLFxyXG4gICAgICAgIGNyZWF0ZUdhdGUoMiwgJzQwLjc0ODUsLTczLjk2NzUnLCAyMzAgKyBNYXRoLnJvdW5kKHZhcmlhdGlvbjIpKSxcclxuICAgICAgICBjcmVhdGVHYXRlKDMsICc0MC43NDgzLC03My45Njk1JywgMTI1ICsgTWF0aC5yb3VuZCh2YXJpYXRpb24zKSksXHJcbiAgICAgICAgY3JlYXRlR2F0ZSg0LCAnNDAuNzQ5MywtNzMuOTY2NScsIDExMiArIE1hdGgucm91bmQodmFyaWF0aW9uNCkpLFxyXG4gICAgXTtcclxuXHJcbiAgICByZXR1cm4gZ2F0ZXM7XHJcbn1cclxuXHJcbi8vIFNpbXVsYXRlIGhhbGwgZGF0YVxyXG5leHBvcnQgZnVuY3Rpb24gc2ltdWxhdGVIYWxsRGF0YSgpOiBIYWxsW10ge1xyXG4gICAgY29uc3QgYmFzZVRpbWUgPSBEYXRlLm5vdygpO1xyXG5cclxuICAgIGNvbnN0IGhhbGxzOiBIYWxsW10gPSBbXHJcbiAgICAgICAgY3JlYXRlSGFsbCgxLCBNYXRoLnJvdW5kKDE4MCArIE1hdGguc2luKGJhc2VUaW1lIC8gNTAwMCkgKiA1MCkpLFxyXG4gICAgICAgIGNyZWF0ZUhhbGwoMiwgTWF0aC5yb3VuZCgzMjAgKyBNYXRoLmNvcyhiYXNlVGltZSAvIDYwMDApICogODApKSxcclxuICAgICAgICBjcmVhdGVIYWxsKDMsIE1hdGgucm91bmQoMTUwICsgTWF0aC5zaW4oYmFzZVRpbWUgLyA3MDAwKSAqIDQwKSksXHJcbiAgICAgICAgY3JlYXRlSGFsbCg0LCBNYXRoLnJvdW5kKDI4MCArIE1hdGguY29zKGJhc2VUaW1lIC8gODAwMCkgKiA2MCkpLFxyXG4gICAgXTtcclxuXHJcbiAgICByZXR1cm4gaGFsbHM7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNyZWF0ZUhhbGwoaGFsbE51bWJlcjogbnVtYmVyLCBjb3VudDogbnVtYmVyKTogSGFsbCB7XHJcbiAgICBjb25zdCBjYXBhY2l0eSA9IDQwMDtcclxuICAgIGNvbnN0IGRlbnNpdHlQZXJjZW50ID0gKGNvdW50IC8gY2FwYWNpdHkpICogMTAwO1xyXG5cclxuICAgIGxldCBjcm93ZExldmVsOiAnbG93JyB8ICdtZWRpdW0nIHwgJ2hpZ2gnIHwgJ2NyaXRpY2FsJztcclxuICAgIGxldCBoZWF0bWFwQ29sb3I6IHN0cmluZztcclxuICAgIGxldCBzdGFtcGVkZV9yaXNrOiAnbG93JyB8ICdtZWRpdW0nIHwgJ2hpZ2gnIHwgJ2NyaXRpY2FsJztcclxuXHJcbiAgICBpZiAoZGVuc2l0eVBlcmNlbnQgPCA0MCkge1xyXG4gICAgICAgIGNyb3dkTGV2ZWwgPSAnbG93JztcclxuICAgICAgICBoZWF0bWFwQ29sb3IgPSAnIzEwYjk4MSc7XHJcbiAgICAgICAgc3RhbXBlZGVfcmlzayA9ICdsb3cnO1xyXG4gICAgfSBlbHNlIGlmIChkZW5zaXR5UGVyY2VudCA8IDYwKSB7XHJcbiAgICAgICAgY3Jvd2RMZXZlbCA9ICdtZWRpdW0nO1xyXG4gICAgICAgIGhlYXRtYXBDb2xvciA9ICcjZjU5ZTBiJztcclxuICAgICAgICBzdGFtcGVkZV9yaXNrID0gJ2xvdyc7XHJcbiAgICB9IGVsc2UgaWYgKGRlbnNpdHlQZXJjZW50IDwgODApIHtcclxuICAgICAgICBjcm93ZExldmVsID0gJ2hpZ2gnO1xyXG4gICAgICAgIGhlYXRtYXBDb2xvciA9ICcjZjk3MzE2JztcclxuICAgICAgICBzdGFtcGVkZV9yaXNrID0gJ21lZGl1bSc7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIGNyb3dkTGV2ZWwgPSAnY3JpdGljYWwnO1xyXG4gICAgICAgIGhlYXRtYXBDb2xvciA9ICcjZWY0NDQ0JztcclxuICAgICAgICBzdGFtcGVkZV9yaXNrID0gJ2hpZ2gnO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgaWQ6IGBoYWxsLSR7aGFsbE51bWJlcn1gLFxyXG4gICAgICAgIG51bWJlcjogaGFsbE51bWJlcixcclxuICAgICAgICBuYW1lOiBgSGFsbCAke2hhbGxOdW1iZXJ9YCxcclxuICAgICAgICBjYXBhY2l0eSxcclxuICAgICAgICBjdXJyZW50X2NvdW50OiBjb3VudCxcclxuICAgICAgICBkZW5zaXR5X3BlcmNlbnQ6IHBhcnNlRmxvYXQoZGVuc2l0eVBlcmNlbnQudG9GaXhlZCgxKSksXHJcbiAgICAgICAgY3Jvd2RfbGV2ZWw6IGNyb3dkTGV2ZWwsXHJcbiAgICAgICAgaGVhdG1hcF9jb2xvcjogaGVhdG1hcENvbG9yLFxyXG4gICAgICAgIHN0YW1wZWRlX3Jpc2ssXHJcbiAgICB9O1xyXG59XHJcblxyXG4vLyBJbml0aWFsaXplIGNyb3dkIHNpbXVsYXRpb24gd2l0aCBwZW9wbGVcclxuZXhwb3J0IGZ1bmN0aW9uIGluaXRpYWxpemVDcm93ZFNpbXVsYXRpb24oaGFsbENvdW50OiBudW1iZXIgPSA0KTogQ3Jvd2RQZXJzb25bXSB7XHJcbiAgICBjb25zdCBwZW9wbGU6IENyb3dkUGVyc29uW10gPSBbXTtcclxuICAgIGNvbnN0IHRvdGFsUGVvcGxlID0gODAwOyAvLyBJbmNyZWFzZWQgZm9yIGJldHRlciB2aXN1YWxzXHJcblxyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0b3RhbFBlb3BsZTsgaSsrKSB7XHJcbiAgICAgICAgY29uc3QgaGFsbCA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIGhhbGxDb3VudCkgKyAxO1xyXG4gICAgICAgIGNvbnN0IHRhcmdldEV4aXQgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiA0KSArIDE7XHJcblxyXG4gICAgICAgIC8vIFBvc2l0aW9uIHdpdGhpbiBoYWxsIGJvdW5kcyAocmFuZG9tIHN0YXJ0KVxyXG4gICAgICAgIGNvbnN0IHsgbWluWCwgbWF4WCwgbWluWSwgbWF4WSB9ID0gZ2V0SGFsbEJvdW5kcyhoYWxsKTtcclxuXHJcbiAgICAgICAgLy8gUmFuZG9tIHBvc2l0aW9uIGluc2lkZSBoYWxsXHJcbiAgICAgICAgY29uc3QgeCA9IG1pblggKyBNYXRoLnJhbmRvbSgpICogKG1heFggLSBtaW5YKTtcclxuICAgICAgICBjb25zdCB5ID0gbWluWSArIE1hdGgucmFuZG9tKCkgKiAobWF4WSAtIG1pblkpO1xyXG5cclxuICAgICAgICBwZW9wbGUucHVzaCh7XHJcbiAgICAgICAgICAgIGlkOiBgcGVyc29uLSR7aX1gLFxyXG4gICAgICAgICAgICB4LFxyXG4gICAgICAgICAgICB5LFxyXG4gICAgICAgICAgICB2eDogMCxcclxuICAgICAgICAgICAgdnk6IDAsXHJcbiAgICAgICAgICAgIGhhbGwsXHJcbiAgICAgICAgICAgIHRhcmdldEV4aXQsXHJcbiAgICAgICAgICAgIHNwZWVkOiAwLjggKyBNYXRoLnJhbmRvbSgpICogMC42LCAvLyBTbGlnaHRseSBmYXN0ZXJcclxuICAgICAgICAgICAgc3RhdHVzOiAnaW5faGFsbCcsXHJcbiAgICAgICAgICAgIHRhcmdldFg6IHgsIC8vIEluaXRpYWxseSBqdXN0IHN0YXlpbmcgcHV0IG9yIG1vdmluZyB0byBoYWxsIGV4aXRcclxuICAgICAgICAgICAgdGFyZ2V0WTogeVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBwZW9wbGU7XHJcbn1cclxuXHJcbi8vIFVwZGF0ZSBjcm93ZCBwb3NpdGlvbnMgZm9yIHN0cnVjdHVyZWQgbW92ZW1lbnRcclxuZXhwb3J0IGZ1bmN0aW9uIHVwZGF0ZUNyb3dkUG9zaXRpb25zKHBlb3BsZTogQ3Jvd2RQZXJzb25bXSk6IENyb3dkUGVyc29uW10ge1xyXG4gICAgcmV0dXJuIHBlb3BsZS5tYXAocGVyc29uID0+IHtcclxuICAgICAgICBsZXQgeyB4LCB5LCBzdGF0dXMsIHRhcmdldFgsIHRhcmdldFksIGhhbGwsIHRhcmdldEV4aXQsIHNwZWVkIH0gPSBwZXJzb247XHJcblxyXG4gICAgICAgIC8vIFN0YXRlIE1hY2hpbmUgZm9yIE1vdmVtZW50XHJcblxyXG4gICAgICAgIC8vIDEuIElOIEhBTEw6IE1vdmUgdG93YXJkcyBoYWxsIGV4aXQgKGNvbm5lY3Rpb24gdG8gY29ycmlkb3IpXHJcbiAgICAgICAgaWYgKHN0YXR1cyA9PT0gJ2luX2hhbGwnKSB7XHJcbiAgICAgICAgICAgIC8vIEdldCBoYWxsIGV4aXQgcG9pbnQgKGFwcHJveGltYXRlIGNlbnRlciBvZiBpbm5lciB3YWxsKVxyXG4gICAgICAgICAgICBjb25zdCBoYWxsRXhpdCA9IGdldEhhbGxFeGl0UG9pbnQoaGFsbCk7XHJcblxyXG4gICAgICAgICAgICAvLyBTZXQgdGFyZ2V0IHRvIGhhbGwgZXhpdFxyXG4gICAgICAgICAgICB0YXJnZXRYID0gaGFsbEV4aXQueDtcclxuICAgICAgICAgICAgdGFyZ2V0WSA9IGhhbGxFeGl0Lnk7XHJcblxyXG4gICAgICAgICAgICAvLyBDaGVjayBpZiByZWFjaGVkIGhhbGwgZXhpdFxyXG4gICAgICAgICAgICBpZiAoZ2V0RGlzdGFuY2UoeCwgeSwgdGFyZ2V0WCwgdGFyZ2V0WSkgPCAyMCkge1xyXG4gICAgICAgICAgICAgICAgc3RhdHVzID0gJ3RvX2NvcnJpZG9yJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gMi4gVE8gQ09SUklET1I6IE1vdmUgaW50byB0aGUgbWFpbiBsYW5lXHJcbiAgICAgICAgZWxzZSBpZiAoc3RhdHVzID09PSAndG9fY29ycmlkb3InKSB7XHJcbiAgICAgICAgICAgIC8vIFRhcmdldCBpcyB0aGUgY2VudHJhbCBjb3JyaWRvciBpbnRlcnNlY3Rpb24gb3IgbGFuZSBlbnRyeVxyXG4gICAgICAgICAgICAvLyBTaW1wbGUgbG9naWM6IG1vdmUgdG93YXJkcyBjZW50ZXIgY29vcmRpbmF0ZXMgYmFzZWQgb24gaGFsbFxyXG4gICAgICAgICAgICBpZiAoaGFsbCA9PT0gMSB8fCBoYWxsID09PSAzKSB0YXJnZXRYID0gMzkwOyAvLyBNb3ZlIHJpZ2h0IHRvIHZlcnRpY2FsIGNvcnJpZG9yXHJcbiAgICAgICAgICAgIGVsc2UgdGFyZ2V0WCA9IDQxMDsgLy8gTW92ZSBsZWZ0IHRvIHZlcnRpY2FsIGNvcnJpZG9yXHJcblxyXG4gICAgICAgICAgICBpZiAoaGFsbCA9PT0gMSB8fCBoYWxsID09PSAyKSB0YXJnZXRZID0gMzkwOyAvLyBNb3ZlIGRvd24gdG8gaG9yaXpvbnRhbFxyXG4gICAgICAgICAgICBlbHNlIHRhcmdldFkgPSA0MTA7IC8vIE1vdmUgdXAgdG8gaG9yaXpvbnRhbFxyXG5cclxuICAgICAgICAgICAgLy8gT25jZSBpbiBjb3JyaWRvciBib3VuZHMsIHN3aXRjaCB0byBsYW5lIG1vdmVtZW50XHJcbiAgICAgICAgICAgIGlmICh4ID4gMzgwICYmIHggPCA0MjAgfHwgeSA+IDM4MCAmJiB5IDwgNDIwKSB7XHJcbiAgICAgICAgICAgICAgICBzdGF0dXMgPSAnaW5fbGFuZSc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIDMuIElOIExBTkU6IE1vdmUgdG93YXJkcyB0YXJnZXQgZXhpdFxyXG4gICAgICAgIGVsc2UgaWYgKHN0YXR1cyA9PT0gJ2luX2xhbmUnKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGV4aXRQb2ludCA9IGdldEV4aXRQb2ludCh0YXJnZXRFeGl0KTtcclxuICAgICAgICAgICAgdGFyZ2V0WCA9IGV4aXRQb2ludC54O1xyXG4gICAgICAgICAgICB0YXJnZXRZID0gZXhpdFBvaW50Lnk7XHJcblxyXG4gICAgICAgICAgICAvLyBJZiBjbG9zZSB0byBleGl0LCBzd2l0Y2ggdG8gYWNjdW11bGF0aW5nXHJcbiAgICAgICAgICAgIGlmIChnZXREaXN0YW5jZSh4LCB5LCB0YXJnZXRYLCB0YXJnZXRZKSA8IDQwKSB7XHJcbiAgICAgICAgICAgICAgICBzdGF0dXMgPSAnYXRfZXhpdCc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIDQuIEFUIEVYSVQ6IENyb3dkL1dhaXQgYmVoYXZpb3JcclxuICAgICAgICBlbHNlIGlmIChzdGF0dXMgPT09ICdhdF9leGl0Jykge1xyXG4gICAgICAgICAgICAvLyBKdXN0IHdpZ2dsZSBhcm91bmQgdGhlIGV4aXQgcG9pbnQgdG8gc2ltdWxhdGUgY3Jvd2RpbmdcclxuICAgICAgICAgICAgY29uc3QgZXhpdFBvaW50ID0gZ2V0RXhpdFBvaW50KHRhcmdldEV4aXQpO1xyXG4gICAgICAgICAgICB0YXJnZXRYID0gZXhpdFBvaW50LnggKyAoTWF0aC5yYW5kb20oKSAtIDAuNSkgKiAzMDtcclxuICAgICAgICAgICAgdGFyZ2V0WSA9IGV4aXRQb2ludC55ICsgKE1hdGgucmFuZG9tKCkgLSAwLjUpICogMzA7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBDYWxjdWxhdGUgdmVsb2NpdHkgdmVjdG9yIHRvd2FyZHMgdGFyZ2V0XHJcbiAgICAgICAgY29uc3QgZHggPSB0YXJnZXRYIC0geDtcclxuICAgICAgICBjb25zdCBkeSA9IHRhcmdldFkgLSB5O1xyXG4gICAgICAgIGNvbnN0IGRpc3QgPSBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xyXG5cclxuICAgICAgICBsZXQgdnggPSAwLCB2eSA9IDA7XHJcblxyXG4gICAgICAgIGlmIChkaXN0ID4gMSkge1xyXG4gICAgICAgICAgICB2eCA9IChkeCAvIGRpc3QpICogc3BlZWQ7XHJcbiAgICAgICAgICAgIHZ5ID0gKGR5IC8gZGlzdCkgKiBzcGVlZDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEFkZCBzb21lIFwiaHVtYW5cIiByYW5kb21uZXNzL3dpZ2dsZVxyXG4gICAgICAgIHZ4ICs9IChNYXRoLnJhbmRvbSgpIC0gMC41KSAqIDAuMjtcclxuICAgICAgICB2eSArPSAoTWF0aC5yYW5kb20oKSAtIDAuNSkgKiAwLjI7XHJcblxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIC4uLnBlcnNvbixcclxuICAgICAgICAgICAgeDogeCArIHZ4LFxyXG4gICAgICAgICAgICB5OiB5ICsgdnksXHJcbiAgICAgICAgICAgIHZ4LFxyXG4gICAgICAgICAgICB2eSxcclxuICAgICAgICAgICAgc3RhdHVzLFxyXG4gICAgICAgICAgICB0YXJnZXRYLFxyXG4gICAgICAgICAgICB0YXJnZXRZXHJcbiAgICAgICAgfTtcclxuICAgIH0pO1xyXG59XHJcblxyXG4vLyBIZWxwZXJzXHJcbmZ1bmN0aW9uIGdldEhhbGxCb3VuZHMoaGFsbDogbnVtYmVyKSB7XHJcbiAgICBpZiAoaGFsbCA9PT0gMSkgcmV0dXJuIHsgbWluWDogMTIwLCBtYXhYOiAzNjAsIG1pblk6IDEyMCwgbWF4WTogMzYwIH07XHJcbiAgICBpZiAoaGFsbCA9PT0gMikgcmV0dXJuIHsgbWluWDogNDQwLCBtYXhYOiA2ODAsIG1pblk6IDEyMCwgbWF4WTogMzYwIH07XHJcbiAgICBpZiAoaGFsbCA9PT0gMykgcmV0dXJuIHsgbWluWDogMTIwLCBtYXhYOiAzNjAsIG1pblk6IDQ0MCwgbWF4WTogNjgwIH07XHJcbiAgICByZXR1cm4geyBtaW5YOiA0NDAsIG1heFg6IDY4MCwgbWluWTogNDQwLCBtYXhZOiA2ODAgfTtcclxufVxyXG5cclxuZnVuY3Rpb24gZ2V0SGFsbEV4aXRQb2ludChoYWxsOiBudW1iZXIpIHtcclxuICAgIC8vIFJldHVybnMgdGhlIHBvaW50IHdoZXJlIGhhbGwgY29ubmVjdHMgdG8gY29ycmlkb3JcclxuICAgIGlmIChoYWxsID09PSAxKSByZXR1cm4geyB4OiAzNzAsIHk6IDM3MCB9OyAvLyBCb3R0b20tcmlnaHQgb2YgSGFsbCAxXHJcbiAgICBpZiAoaGFsbCA9PT0gMikgcmV0dXJuIHsgeDogNDMwLCB5OiAzNzAgfTsgLy8gQm90dG9tLWxlZnQgb2YgSGFsbCAyXHJcbiAgICBpZiAoaGFsbCA9PT0gMykgcmV0dXJuIHsgeDogMzcwLCB5OiA0MzAgfTsgLy8gVG9wLXJpZ2h0IG9mIEhhbGwgM1xyXG4gICAgcmV0dXJuIHsgeDogNDMwLCB5OiA0MzAgfTsgLy8gVG9wLWxlZnQgb2YgSGFsbCA0XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldEV4aXRQb2ludChleGl0OiBudW1iZXIpIHtcclxuICAgIGlmIChleGl0ID09PSAxKSByZXR1cm4geyB4OiA0MDAsIHk6IDMwIH07IC8vIFRvcFxyXG4gICAgaWYgKGV4aXQgPT09IDIpIHJldHVybiB7IHg6IDc3MCwgeTogNDAwIH07IC8vIFJpZ2h0XHJcbiAgICBpZiAoZXhpdCA9PT0gMykgcmV0dXJuIHsgeDogNDAwLCB5OiA3NzAgfTsgLy8gQm90dG9tXHJcbiAgICByZXR1cm4geyB4OiAzMCwgeTogNDAwIH07IC8vIExlZnRcclxufVxyXG5cclxuZnVuY3Rpb24gZ2V0RGlzdGFuY2UoeDE6IG51bWJlciwgeTE6IG51bWJlciwgeDI6IG51bWJlciwgeTI6IG51bWJlcikge1xyXG4gICAgcmV0dXJuIE1hdGguc3FydChNYXRoLnBvdyh4MiAtIHgxLCAyKSArIE1hdGgucG93KHkyIC0geTEsIDIpKTtcclxufVxyXG5cclxuLy8gR2VuZXJhdGUgZHluYW1pYyByb3V0aW5nIGFsZXJ0c1xyXG5leHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGVSb3V0aW5nQWxlcnQoZ2F0ZXM6IEdhdGVbXSwgaGFsbHM6IEhhbGxbXSk6IEFsZXJ0IHwgbnVsbCB7XHJcbiAgICBjb25zdCBiZXN0R2F0ZSA9IGdhdGVzLnJlZHVjZSgoYmVzdCwgY3VycmVudCkgPT5cclxuICAgICAgICBjdXJyZW50Lm1ldHJpY3Mud2FpdF90aW1lX3NlY29uZHMgPCBiZXN0Lm1ldHJpY3Mud2FpdF90aW1lX3NlY29uZHMgPyBjdXJyZW50IDogYmVzdFxyXG4gICAgKTtcclxuXHJcbiAgICBjb25zdCB3b3JzdEdhdGUgPSBnYXRlcy5yZWR1Y2UoKHdvcnN0LCBjdXJyZW50KSA9PlxyXG4gICAgICAgIGN1cnJlbnQubWV0cmljcy53YWl0X3RpbWVfc2Vjb25kcyA+IHdvcnN0Lm1ldHJpY3Mud2FpdF90aW1lX3NlY29uZHMgPyBjdXJyZW50IDogd29yc3RcclxuICAgICk7XHJcblxyXG4gICAgLy8gQ2hlY2sgZm9yIGhpZ2gtcmlzayBoYWxsc1xyXG4gICAgY29uc3QgaGlnaFJpc2tIYWxscyA9IGhhbGxzLmZpbHRlcihoID0+IGguc3RhbXBlZGVfcmlzayA9PT0gJ2hpZ2gnIHx8IGguc3RhbXBlZGVfcmlzayA9PT0gJ2NyaXRpY2FsJyk7XHJcblxyXG4gICAgaWYgKGhpZ2hSaXNrSGFsbHMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGlkOiBgYWxlcnQtJHtEYXRlLm5vdygpfWAsXHJcbiAgICAgICAgICAgIHR5cGU6ICdzdGFtcGVkZScsXHJcbiAgICAgICAgICAgIHNldmVyaXR5OiAnY3JpdGljYWwnLFxyXG4gICAgICAgICAgICBtZXNzYWdlOiBg4pqg77iPIEhpZ2ggc3RhbXBlZGUgcmlzayBpbiAke2hpZ2hSaXNrSGFsbHMubWFwKGggPT4gaC5uYW1lKS5qb2luKCcsICcpfSEgQXZvaWQgdGhlc2UgYXJlYXMuYCxcclxuICAgICAgICAgICAgc3VnZ2VzdGVkRXhpdDogYmVzdEdhdGUuZ2F0ZV9udW1iZXIsXHJcbiAgICAgICAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKSxcclxuICAgICAgICAgICAgYWN0aXZlOiB0cnVlLFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHdvcnN0R2F0ZS5jcm93ZF9sZXZlbCA9PT0gJ2NyaXRpY2FsJyAmJiBiZXN0R2F0ZS5jcm93ZF9sZXZlbCA9PT0gJ2xvdycpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBpZDogYGFsZXJ0LSR7RGF0ZS5ub3coKX1gLFxyXG4gICAgICAgICAgICB0eXBlOiAncm91dGluZycsXHJcbiAgICAgICAgICAgIHNldmVyaXR5OiAnaGlnaCcsXHJcbiAgICAgICAgICAgIG1lc3NhZ2U6IGDwn5qoIEV4aXQgJHt3b3JzdEdhdGUuZ2F0ZV9udW1iZXJ9IGlzIG92ZXJjcm93ZGVkISBVc2UgRXhpdCAke2Jlc3RHYXRlLmdhdGVfbnVtYmVyfSBpbnN0ZWFkICgke2Jlc3RHYXRlLm1ldHJpY3Mud2FpdF90aW1lX2Zvcm1hdHRlZH0gd2FpdCkuYCxcclxuICAgICAgICAgICAgc3VnZ2VzdGVkRXhpdDogYmVzdEdhdGUuZ2F0ZV9udW1iZXIsXHJcbiAgICAgICAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKSxcclxuICAgICAgICAgICAgYWN0aXZlOiB0cnVlLFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHdvcnN0R2F0ZS5jcm93ZF9sZXZlbCA9PT0gJ2hpZ2gnICYmIGJlc3RHYXRlLmNyb3dkX2xldmVsID09PSAnbG93Jykge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGlkOiBgYWxlcnQtJHtEYXRlLm5vdygpfWAsXHJcbiAgICAgICAgICAgIHR5cGU6ICdyb3V0aW5nJyxcclxuICAgICAgICAgICAgc2V2ZXJpdHk6ICdtZWRpdW0nLFxyXG4gICAgICAgICAgICBtZXNzYWdlOiBg8J+SoSBFeGl0ICR7YmVzdEdhdGUuZ2F0ZV9udW1iZXJ9IGhhcyB0aGUgc2hvcnRlc3Qgd2FpdCB0aW1lICgke2Jlc3RHYXRlLm1ldHJpY3Mud2FpdF90aW1lX2Zvcm1hdHRlZH0pLmAsXHJcbiAgICAgICAgICAgIHN1Z2dlc3RlZEV4aXQ6IGJlc3RHYXRlLmdhdGVfbnVtYmVyLFxyXG4gICAgICAgICAgICB0aW1lc3RhbXA6IERhdGUubm93KCksXHJcbiAgICAgICAgICAgIGFjdGl2ZTogdHJ1ZSxcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBudWxsO1xyXG59XHJcblxyXG5mdW5jdGlvbiBjcmVhdGVHYXRlKGdhdGVOdW1iZXI6IG51bWJlciwgY29vcmRpbmF0ZXM6IHN0cmluZywgY291bnQ6IG51bWJlcik6IEdhdGUge1xyXG4gICAgY29uc3QgW2xhdCwgbG9uXSA9IGNvb3JkaW5hdGVzLnNwbGl0KCcsJykubWFwKE51bWJlcik7XHJcblxyXG4gICAgLy8gRGV0ZXJtaW5lIGNyb3dkIGxldmVsXHJcbiAgICBsZXQgY3Jvd2RMZXZlbDogJ2xvdycgfCAnbWVkaXVtJyB8ICdoaWdoJyB8ICdjcml0aWNhbCc7XHJcbiAgICBsZXQgY3Jvd2RDb2xvcjogc3RyaW5nO1xyXG5cclxuICAgIGlmIChjb3VudCA8IDgwKSB7XHJcbiAgICAgICAgY3Jvd2RMZXZlbCA9ICdsb3cnO1xyXG4gICAgICAgIGNyb3dkQ29sb3IgPSAnIzEwYjk4MSc7XHJcbiAgICB9IGVsc2UgaWYgKGNvdW50IDwgMTUwKSB7XHJcbiAgICAgICAgY3Jvd2RMZXZlbCA9ICdtZWRpdW0nO1xyXG4gICAgICAgIGNyb3dkQ29sb3IgPSAnI2Y1OWUwYic7XHJcbiAgICB9IGVsc2UgaWYgKGNvdW50IDwgMjIwKSB7XHJcbiAgICAgICAgY3Jvd2RMZXZlbCA9ICdoaWdoJztcclxuICAgICAgICBjcm93ZENvbG9yID0gJyNmOTczMTYnO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBjcm93ZExldmVsID0gJ2NyaXRpY2FsJztcclxuICAgICAgICBjcm93ZENvbG9yID0gJyNlZjQ0NDQnO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIENhbGN1bGF0ZSBtZXRyaWNzXHJcbiAgICBjb25zdCBkZW5zaXR5ID0gY291bnQgLyAyMDA7XHJcbiAgICBjb25zdCB3YWl0VGltZSA9IE1hdGgubWF4KDMwLCBjb3VudCAqIDIpO1xyXG4gICAgY29uc3QgcXVldWVMZW5ndGggPSBjb3VudCAqIDAuMDg7XHJcblxyXG4gICAgLy8gR2VuZXJhdGUgdHJlbmRcclxuICAgIGNvbnN0IHNwYXJrbGluZSA9IGdlbmVyYXRlU3BhcmtsaW5lKGNvdW50KTtcclxuICAgIGNvbnN0IHRyZW5kID0gZGV0ZXJtaW5lVHJlbmQoc3BhcmtsaW5lKTtcclxuXHJcbiAgICAvLyBHYXRlIG5hbWVzXHJcbiAgICBjb25zdCBnYXRlTmFtZXMgPSBbJ05vcnRoIEV4aXQgKEV4aXQgMSknLCAnRWFzdCBFeGl0IChFeGl0IDIpJywgJ1NvdXRoIEV4aXQgKEV4aXQgMyknLCAnV2VzdCBFeGl0IChFeGl0IDQpJ107XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBpZDogYGdhdGUtJHtnYXRlTnVtYmVyfWAsXHJcbiAgICAgICAgZ2F0ZV9udW1iZXI6IGdhdGVOdW1iZXIsXHJcbiAgICAgICAgbmFtZTogZ2F0ZU5hbWVzW2dhdGVOdW1iZXIgLSAxXSxcclxuICAgICAgICBsb2NhdGlvbjogeyBsYXQsIGxvbiB9LFxyXG4gICAgICAgIHN0YXR1czogJ2FjdGl2ZScsXHJcbiAgICAgICAgY3Jvd2RfbGV2ZWw6IGNyb3dkTGV2ZWwsXHJcbiAgICAgICAgY3Jvd2RfY29sb3I6IGNyb3dkQ29sb3IsXHJcbiAgICAgICAgbWV0cmljczoge1xyXG4gICAgICAgICAgICBwZW9wbGVfY291bnQ6IGNvdW50LFxyXG4gICAgICAgICAgICBkZW5zaXR5OiBwYXJzZUZsb2F0KGRlbnNpdHkudG9GaXhlZCgyKSksXHJcbiAgICAgICAgICAgIGRlbnNpdHlfbGV2ZWw6IGNyb3dkTGV2ZWwsXHJcbiAgICAgICAgICAgIHdhaXRfdGltZV9zZWNvbmRzOiB3YWl0VGltZSxcclxuICAgICAgICAgICAgd2FpdF90aW1lX2Zvcm1hdHRlZDogZm9ybWF0V2FpdFRpbWUod2FpdFRpbWUpLFxyXG4gICAgICAgICAgICBxdWV1ZV9sZW5ndGhfbWV0ZXJzOiBwYXJzZUZsb2F0KHF1ZXVlTGVuZ3RoLnRvRml4ZWQoMSkpLFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgdHJlbmQsXHJcbiAgICAgICAgcHJlZGljdGlvbjoge1xyXG4gICAgICAgICAgICAnNV9taW5fYWhlYWQnOiB7XHJcbiAgICAgICAgICAgICAgICBjb3VudDogTWF0aC5yb3VuZChjb3VudCAqICgxICsgKE1hdGgucmFuZG9tKCkgLSAwLjQpICogMC4yKSksXHJcbiAgICAgICAgICAgICAgICBjb25maWRlbmNlOiAwLjg1ICsgTWF0aC5yYW5kb20oKSAqIDAuMSxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgJzEwX21pbl9haGVhZCc6IHtcclxuICAgICAgICAgICAgICAgIGNvdW50OiBNYXRoLnJvdW5kKGNvdW50ICogKDEgKyAoTWF0aC5yYW5kb20oKSAtIDAuNCkgKiAwLjMpKSxcclxuICAgICAgICAgICAgICAgIGNvbmZpZGVuY2U6IDAuNzUgKyBNYXRoLnJhbmRvbSgpICogMC4xLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgaGFzX2FjY2Vzc2liaWxpdHk6IGdhdGVOdW1iZXIgPT09IDEgfHwgZ2F0ZU51bWJlciA9PT0gMyxcclxuICAgICAgICBlZmZpY2llbmN5X3BlcmNlbnQ6IE1hdGgucm91bmQoNzAgKyBNYXRoLnJhbmRvbSgpICogMjUpLFxyXG4gICAgfTtcclxufVxyXG5cclxuZnVuY3Rpb24gZ2VuZXJhdGVTcGFya2xpbmUoY3VycmVudENvdW50OiBudW1iZXIpOiBudW1iZXJbXSB7XHJcbiAgICBjb25zdCBwb2ludHMgPSAxMDtcclxuICAgIGNvbnN0IHNwYXJrbGluZTogbnVtYmVyW10gPSBbXTtcclxuICAgIGxldCB2YWx1ZSA9IGN1cnJlbnRDb3VudCAtIDIwO1xyXG5cclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcG9pbnRzOyBpKyspIHtcclxuICAgICAgICB2YWx1ZSArPSAoTWF0aC5yYW5kb20oKSAtIDAuNSkgKiAxMDtcclxuICAgICAgICB2YWx1ZSA9IE1hdGgubWF4KDIwLCBNYXRoLm1pbigzMDAsIHZhbHVlKSk7XHJcbiAgICAgICAgc3BhcmtsaW5lLnB1c2goTWF0aC5yb3VuZCh2YWx1ZSkpO1xyXG4gICAgfVxyXG5cclxuICAgIHNwYXJrbGluZVtzcGFya2xpbmUubGVuZ3RoIC0gMV0gPSBjdXJyZW50Q291bnQ7XHJcbiAgICByZXR1cm4gc3BhcmtsaW5lO1xyXG59XHJcblxyXG5mdW5jdGlvbiBkZXRlcm1pbmVUcmVuZChzcGFya2xpbmU6IG51bWJlcltdKToge1xyXG4gICAgZGlyZWN0aW9uOiAnaW5jcmVhc2luZycgfCAnc3RhYmxlJyB8ICdkZWNyZWFzaW5nJztcclxuICAgIGNoYW5nZV9wZXJjZW50OiBudW1iZXI7XHJcbn0ge1xyXG4gICAgY29uc3QgZmlyc3QgPSBzcGFya2xpbmVbMF07XHJcbiAgICBjb25zdCBsYXN0ID0gc3BhcmtsaW5lW3NwYXJrbGluZS5sZW5ndGggLSAxXTtcclxuICAgIGNvbnN0IGNoYW5nZSA9ICgobGFzdCAtIGZpcnN0KSAvIGZpcnN0KSAqIDEwMDtcclxuXHJcbiAgICBsZXQgZGlyZWN0aW9uOiAnaW5jcmVhc2luZycgfCAnc3RhYmxlJyB8ICdkZWNyZWFzaW5nJztcclxuICAgIGlmIChjaGFuZ2UgPiAxMCkge1xyXG4gICAgICAgIGRpcmVjdGlvbiA9ICdpbmNyZWFzaW5nJztcclxuICAgIH0gZWxzZSBpZiAoY2hhbmdlIDwgLTEwKSB7XHJcbiAgICAgICAgZGlyZWN0aW9uID0gJ2RlY3JlYXNpbmcnO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBkaXJlY3Rpb24gPSAnc3RhYmxlJztcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGRpcmVjdGlvbixcclxuICAgICAgICBjaGFuZ2VfcGVyY2VudDogcGFyc2VGbG9hdChNYXRoLmFicyhjaGFuZ2UpLnRvRml4ZWQoMSkpLFxyXG4gICAgICAgIHNwYXJrbGluZVxyXG4gICAgfTtcclxufVxyXG5cclxuZnVuY3Rpb24gZm9ybWF0V2FpdFRpbWUoc2Vjb25kczogbnVtYmVyKTogc3RyaW5nIHtcclxuICAgIGNvbnN0IG1pbnV0ZXMgPSBNYXRoLnJvdW5kKHNlY29uZHMgLyA2MCk7XHJcbiAgICBpZiAobWludXRlcyA9PT0gMCkgcmV0dXJuICc8MSBtaW51dGUnO1xyXG4gICAgaWYgKG1pbnV0ZXMgPT09IDEpIHJldHVybiAnMSBtaW51dGUnO1xyXG4gICAgcmV0dXJuIGAke21pbnV0ZXN9IG1pbnV0ZXNgO1xyXG59XHJcbiJdLCJuYW1lcyI6WyJzaW11bGF0ZUNyb3dkRGF0YSIsImJhc2VUaW1lIiwiRGF0ZSIsIm5vdyIsInZhcmlhdGlvbjEiLCJNYXRoIiwic2luIiwicmFuZG9tIiwidmFyaWF0aW9uMiIsImNvcyIsInZhcmlhdGlvbjMiLCJ2YXJpYXRpb240IiwiZ2F0ZXMiLCJjcmVhdGVHYXRlIiwicm91bmQiLCJzaW11bGF0ZUhhbGxEYXRhIiwiaGFsbHMiLCJjcmVhdGVIYWxsIiwiaGFsbE51bWJlciIsImNvdW50IiwiY2FwYWNpdHkiLCJkZW5zaXR5UGVyY2VudCIsImNyb3dkTGV2ZWwiLCJoZWF0bWFwQ29sb3IiLCJzdGFtcGVkZV9yaXNrIiwiaWQiLCJudW1iZXIiLCJuYW1lIiwiY3VycmVudF9jb3VudCIsImRlbnNpdHlfcGVyY2VudCIsInBhcnNlRmxvYXQiLCJ0b0ZpeGVkIiwiY3Jvd2RfbGV2ZWwiLCJoZWF0bWFwX2NvbG9yIiwiaW5pdGlhbGl6ZUNyb3dkU2ltdWxhdGlvbiIsImhhbGxDb3VudCIsInBlb3BsZSIsInRvdGFsUGVvcGxlIiwiaSIsImhhbGwiLCJmbG9vciIsInRhcmdldEV4aXQiLCJtaW5YIiwibWF4WCIsIm1pblkiLCJtYXhZIiwiZ2V0SGFsbEJvdW5kcyIsIngiLCJ5IiwicHVzaCIsInZ4IiwidnkiLCJzcGVlZCIsInN0YXR1cyIsInRhcmdldFgiLCJ0YXJnZXRZIiwidXBkYXRlQ3Jvd2RQb3NpdGlvbnMiLCJtYXAiLCJwZXJzb24iLCJoYWxsRXhpdCIsImdldEhhbGxFeGl0UG9pbnQiLCJnZXREaXN0YW5jZSIsImV4aXRQb2ludCIsImdldEV4aXRQb2ludCIsImR4IiwiZHkiLCJkaXN0Iiwic3FydCIsImV4aXQiLCJ4MSIsInkxIiwieDIiLCJ5MiIsInBvdyIsImdlbmVyYXRlUm91dGluZ0FsZXJ0IiwiYmVzdEdhdGUiLCJyZWR1Y2UiLCJiZXN0IiwiY3VycmVudCIsIm1ldHJpY3MiLCJ3YWl0X3RpbWVfc2Vjb25kcyIsIndvcnN0R2F0ZSIsIndvcnN0IiwiaGlnaFJpc2tIYWxscyIsImZpbHRlciIsImgiLCJsZW5ndGgiLCJ0eXBlIiwic2V2ZXJpdHkiLCJtZXNzYWdlIiwiam9pbiIsInN1Z2dlc3RlZEV4aXQiLCJnYXRlX251bWJlciIsInRpbWVzdGFtcCIsImFjdGl2ZSIsIndhaXRfdGltZV9mb3JtYXR0ZWQiLCJnYXRlTnVtYmVyIiwiY29vcmRpbmF0ZXMiLCJsYXQiLCJsb24iLCJzcGxpdCIsIk51bWJlciIsImNyb3dkQ29sb3IiLCJkZW5zaXR5Iiwid2FpdFRpbWUiLCJtYXgiLCJxdWV1ZUxlbmd0aCIsInNwYXJrbGluZSIsImdlbmVyYXRlU3BhcmtsaW5lIiwidHJlbmQiLCJkZXRlcm1pbmVUcmVuZCIsImdhdGVOYW1lcyIsImxvY2F0aW9uIiwiY3Jvd2RfY29sb3IiLCJwZW9wbGVfY291bnQiLCJkZW5zaXR5X2xldmVsIiwiZm9ybWF0V2FpdFRpbWUiLCJxdWV1ZV9sZW5ndGhfbWV0ZXJzIiwicHJlZGljdGlvbiIsImNvbmZpZGVuY2UiLCJoYXNfYWNjZXNzaWJpbGl0eSIsImVmZmljaWVuY3lfcGVyY2VudCIsImN1cnJlbnRDb3VudCIsInBvaW50cyIsInZhbHVlIiwibWluIiwiZmlyc3QiLCJsYXN0IiwiY2hhbmdlIiwiZGlyZWN0aW9uIiwiY2hhbmdlX3BlcmNlbnQiLCJhYnMiLCJzZWNvbmRzIiwibWludXRlcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/mockData.ts\n"));

/***/ })

});