"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./lib/mockData.ts":
/*!*************************!*\
  !*** ./lib/mockData.ts ***!
  \*************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   generateRoutingAlert: function() { return /* binding */ generateRoutingAlert; },\n/* harmony export */   initializeCrowdSimulation: function() { return /* binding */ initializeCrowdSimulation; },\n/* harmony export */   simulateCrowdData: function() { return /* binding */ simulateCrowdData; },\n/* harmony export */   simulateHallData: function() { return /* binding */ simulateHallData; },\n/* harmony export */   updateCrowdPositions: function() { return /* binding */ updateCrowdPositions; }\n/* harmony export */ });\n// Simulate realistic crowd data for the 4 gates\nfunction simulateCrowdData() {\n    const baseTime = Date.now();\n    // Create realistic variations in crowd levels\n    const variation1 = Math.sin(baseTime / 10000) * 20 + Math.random() * 10;\n    const variation2 = Math.cos(baseTime / 8000) * 30 + Math.random() * 15;\n    const variation3 = Math.sin(baseTime / 12000) * 25 + Math.random() * 12;\n    const variation4 = Math.cos(baseTime / 15000) * 18 + Math.random() * 8;\n    const gates = [\n        createGate(1, \"40.7495,-73.9685\", 45 + Math.round(variation1)),\n        createGate(2, \"40.7485,-73.9675\", 230 + Math.round(variation2)),\n        createGate(3, \"40.7483,-73.9695\", 125 + Math.round(variation3)),\n        createGate(4, \"40.7493,-73.9665\", 112 + Math.round(variation4))\n    ];\n    return gates;\n}\n// Simulate hall data\nfunction simulateHallData() {\n    const baseTime = Date.now();\n    const halls = [\n        createHall(1, Math.round(180 + Math.sin(baseTime / 5000) * 50)),\n        createHall(2, Math.round(320 + Math.cos(baseTime / 6000) * 80)),\n        createHall(3, Math.round(150 + Math.sin(baseTime / 7000) * 40)),\n        createHall(4, Math.round(280 + Math.cos(baseTime / 8000) * 60))\n    ];\n    return halls;\n}\nfunction createHall(hallNumber, count) {\n    const capacity = 400;\n    const densityPercent = count / capacity * 100;\n    let crowdLevel;\n    let heatmapColor;\n    let stampede_risk;\n    if (densityPercent < 40) {\n        crowdLevel = \"low\";\n        heatmapColor = \"#10b981\";\n        stampede_risk = \"low\";\n    } else if (densityPercent < 60) {\n        crowdLevel = \"medium\";\n        heatmapColor = \"#f59e0b\";\n        stampede_risk = \"low\";\n    } else if (densityPercent < 80) {\n        crowdLevel = \"high\";\n        heatmapColor = \"#f97316\";\n        stampede_risk = \"medium\";\n    } else {\n        crowdLevel = \"critical\";\n        heatmapColor = \"#ef4444\";\n        stampede_risk = \"high\";\n    }\n    return {\n        id: \"hall-\".concat(hallNumber),\n        number: hallNumber,\n        name: \"Hall \".concat(hallNumber),\n        capacity,\n        current_count: count,\n        density_percent: parseFloat(densityPercent.toFixed(1)),\n        crowd_level: crowdLevel,\n        heatmap_color: heatmapColor,\n        stampede_risk\n    };\n}\n// Initialize crowd simulation with people\nfunction initializeCrowdSimulation() {\n    let hallCount = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 4;\n    const people = [];\n    const totalPeople = 800;\n    for(let i = 0; i < totalPeople; i++){\n        const hall = Math.floor(Math.random() * hallCount) + 1;\n        const targetExit = Math.floor(Math.random() * 4) + 1;\n        // Initial placement logic\n        let x, y;\n        if (hall === 1) {\n            x = 120 + Math.random() * 240;\n            y = 120 + Math.random() * 240;\n        } else if (hall === 2) {\n            x = 440 + Math.random() * 240;\n            y = 120 + Math.random() * 240;\n        } else if (hall === 3) {\n            x = 120 + Math.random() * 240;\n            y = 440 + Math.random() * 240;\n        } else {\n            x = 440 + Math.random() * 240;\n            y = 440 + Math.random() * 240;\n        }\n        people.push({\n            id: \"person-\".concat(i),\n            x,\n            y,\n            vx: 0,\n            vy: 0,\n            hall,\n            targetExit,\n            speed: 0.5 + Math.random() * 0.5,\n            status: \"in_hall\"\n        });\n    }\n    return people;\n}\n// Update crowd positions for animation with structured movement\nfunction updateCrowdPositions(people) {\n    return people.map((person)=>{\n        let { x, y, status, targetExit, hall, speed } = person;\n        let vx = 0;\n        let vy = 0;\n        // Structured Movement Logic\n        if (status === \"in_hall\") {\n            // Move towards the central corridor \"gate\" of the hall\n            // Hall 1 (TL) -> Target: (380, 240) or (240, 380) depending on exit?\n            // Simplified: All halls empty into the central cross intersection area\n            let targetX = 400;\n            let targetY = 400;\n            if (hall === 1) {\n                targetX = 370;\n                targetY = 370;\n            } else if (hall === 2) {\n                targetX = 430;\n                targetY = 370;\n            } else if (hall === 3) {\n                targetX = 370;\n                targetY = 430;\n            } else if (hall === 4) {\n                targetX = 430;\n                targetY = 430;\n            }\n            // Move towards target\n            const dx = targetX - x;\n            const dy = targetY - y;\n            const dist = Math.sqrt(dx * dx + dy * dy);\n            if (dist < 10) {\n                status = \"merging\";\n            } else {\n                vx = dx / dist * speed;\n                vy = dy / dist * speed;\n            }\n        } else if (status === \"merging\") {\n            // Move to center of corridor lanes\n            const targetX = 400;\n            const targetY = 400;\n            const dx = targetX - x;\n            const dy = targetY - y;\n            const dist = Math.sqrt(dx * dx + dy * dy);\n            if (dist < 5) {\n                status = \"in_lane\";\n            } else {\n                vx = dx / dist * speed;\n                vy = dy / dist * speed;\n            }\n        } else if (status === \"in_lane\") {\n            // Move along the main axes towards target exit\n            // Exit 1 (Top): x=380..420, y -> 0\n            // Exit 2 (Right): y=380..420, x -> 800\n            // Exit 3 (Bottom): x=380..420, y -> 800\n            // Exit 4 (Left): y=380..420, x -> 0\n            if (targetExit === 1) {\n                if (Math.abs(x - 400) > 15) {\n                    vx = (400 - x) * 0.1;\n                } else {\n                    vy = -speed * 1.5; // Move Up\n                }\n                if (y < 50) status = \"at_exit\";\n            } else if (targetExit === 2) {\n                if (Math.abs(y - 400) > 15) {\n                    vy = (400 - y) * 0.1;\n                } else {\n                    vx = speed * 1.5; // Move Right\n                }\n                if (x > 750) status = \"at_exit\";\n            } else if (targetExit === 3) {\n                if (Math.abs(x - 400) > 15) {\n                    vx = (400 - x) * 0.1;\n                } else {\n                    vy = speed * 1.5; // Move Down\n                }\n                if (y > 750) status = \"at_exit\";\n            } else if (targetExit === 4) {\n                if (Math.abs(y - 400) > 15) {\n                    vy = (400 - y) * 0.1;\n                } else {\n                    vx = -speed * 1.5; // Move Left\n                }\n                if (x < 50) status = \"at_exit\";\n            }\n        } else if (status === \"at_exit\") {\n            // Congregate and move slowly near exit\n            // Add some jitter to look like a crowd\n            vx = (Math.random() - 0.5) * 0.5;\n            vy = (Math.random() - 0.5) * 0.5;\n            // Keep within exit zone\n            if (targetExit === 1) {\n                if (y > 60) vy -= 0.2;\n                if (y < 10) vy += 0.2;\n                if (x < 360) vx += 0.2;\n                if (x > 440) vx -= 0.2;\n            } else if (targetExit === 2) {\n                if (x < 740) vx += 0.2;\n                if (x > 790) vx -= 0.2;\n                if (y < 360) vy += 0.2;\n                if (y > 440) vy -= 0.2;\n            } else if (targetExit === 3) {\n                if (y < 740) vy += 0.2;\n                if (y > 790) vy -= 0.2;\n                if (x < 360) vx += 0.2;\n                if (x > 440) vx -= 0.2;\n            } else if (targetExit === 4) {\n                if (x > 60) vx -= 0.2;\n                if (x < 10) vx += 0.2;\n                if (y < 360) vy += 0.2;\n                if (y > 440) vy -= 0.2;\n            }\n            // Occasionally reset to hall to keep simulation flowing\n            if (Math.random() < 0.005) {\n                status = \"in_hall\";\n                hall = Math.floor(Math.random() * 4) + 1;\n                person.targetExit = Math.floor(Math.random() * 4) + 1; // Pick new target\n                // Reset pos\n                if (hall === 1) {\n                    x = 200;\n                    y = 200;\n                } else if (hall === 2) {\n                    x = 600;\n                    y = 200;\n                } else if (hall === 3) {\n                    x = 200;\n                    y = 600;\n                } else {\n                    x = 600;\n                    y = 600;\n                }\n            }\n        }\n        // Apply movement\n        let newX = x + vx;\n        let newY = y + vy;\n        // Hard boundaries for map\n        newX = Math.max(0, Math.min(800, newX));\n        newY = Math.max(0, Math.min(800, newY));\n        return {\n            ...person,\n            x: newX,\n            y: newY,\n            vx,\n            vy,\n            status,\n            hall\n        };\n    });\n}\n// Generate dynamic routing alerts\nfunction generateRoutingAlert(gates, halls) {\n    const bestGate = gates.reduce((best, current)=>current.metrics.wait_time_seconds < best.metrics.wait_time_seconds ? current : best);\n    const worstGate = gates.reduce((worst, current)=>current.metrics.wait_time_seconds > worst.metrics.wait_time_seconds ? current : worst);\n    // Check for high-risk halls\n    const highRiskHalls = halls.filter((h)=>h.stampede_risk === \"high\" || h.stampede_risk === \"critical\");\n    if (highRiskHalls.length > 0) {\n        return {\n            id: \"alert-\".concat(Date.now()),\n            type: \"stampede\",\n            severity: \"critical\",\n            message: \"⚠️ High stampede risk in \".concat(highRiskHalls.map((h)=>h.name).join(\", \"), \"! Avoid these areas.\"),\n            suggestedExit: bestGate.gate_number,\n            timestamp: Date.now(),\n            active: true\n        };\n    }\n    if (worstGate.crowd_level === \"critical\" && bestGate.crowd_level === \"low\") {\n        return {\n            id: \"alert-\".concat(Date.now()),\n            type: \"routing\",\n            severity: \"high\",\n            message: \"\\uD83D\\uDEA8 Exit \".concat(worstGate.gate_number, \" is overcrowded! Use Exit \").concat(bestGate.gate_number, \" instead (\").concat(bestGate.metrics.wait_time_formatted, \" wait).\"),\n            suggestedExit: bestGate.gate_number,\n            timestamp: Date.now(),\n            active: true\n        };\n    }\n    if (worstGate.crowd_level === \"high\" && bestGate.crowd_level === \"low\") {\n        return {\n            id: \"alert-\".concat(Date.now()),\n            type: \"routing\",\n            severity: \"medium\",\n            message: \"\\uD83D\\uDCA1 Exit \".concat(bestGate.gate_number, \" has the shortest wait time (\").concat(bestGate.metrics.wait_time_formatted, \").\"),\n            suggestedExit: bestGate.gate_number,\n            timestamp: Date.now(),\n            active: true\n        };\n    }\n    return null;\n}\nfunction createGate(gateNumber, coordinates, count) {\n    const [lat, lon] = coordinates.split(\",\").map(Number);\n    // Determine crowd level\n    let crowdLevel;\n    let crowdColor;\n    if (count < 80) {\n        crowdLevel = \"low\";\n        crowdColor = \"#10b981\";\n    } else if (count < 150) {\n        crowdLevel = \"medium\";\n        crowdColor = \"#f59e0b\";\n    } else if (count < 220) {\n        crowdLevel = \"high\";\n        crowdColor = \"#f97316\";\n    } else {\n        crowdLevel = \"critical\";\n        crowdColor = \"#ef4444\";\n    }\n    // Calculate metrics\n    const density = count / 200;\n    const waitTime = Math.max(30, count * 2);\n    const queueLength = count * 0.08;\n    // Generate trend\n    const sparkline = generateSparkline(count);\n    const trend = determineTrend(sparkline);\n    // Gate names\n    const gateNames = [\n        \"North Exit (Exit 1)\",\n        \"East Exit (Exit 2)\",\n        \"South Exit (Exit 3)\",\n        \"West Exit (Exit 4)\"\n    ];\n    return {\n        id: \"gate-\".concat(gateNumber),\n        gate_number: gateNumber,\n        name: gateNames[gateNumber - 1],\n        location: {\n            lat,\n            lon\n        },\n        status: \"active\",\n        crowd_level: crowdLevel,\n        crowd_color: crowdColor,\n        metrics: {\n            people_count: count,\n            density: parseFloat(density.toFixed(2)),\n            density_level: crowdLevel,\n            wait_time_seconds: waitTime,\n            wait_time_formatted: formatWaitTime(waitTime),\n            queue_length_meters: parseFloat(queueLength.toFixed(1))\n        },\n        trend: {\n            ...trend,\n            sparkline\n        },\n        prediction: {\n            \"5_min_ahead\": {\n                count: Math.round(count * (1 + (Math.random() - 0.4) * 0.2)),\n                confidence: 0.85 + Math.random() * 0.1\n            },\n            \"10_min_ahead\": {\n                count: Math.round(count * (1 + (Math.random() - 0.4) * 0.3)),\n                confidence: 0.75 + Math.random() * 0.1\n            }\n        },\n        has_accessibility: gateNumber === 1 || gateNumber === 3,\n        efficiency_percent: Math.round(70 + Math.random() * 25)\n    };\n}\nfunction generateSparkline(currentCount) {\n    const points = 10;\n    const sparkline = [];\n    let value = currentCount - 20;\n    for(let i = 0; i < points; i++){\n        value += (Math.random() - 0.5) * 10;\n        value = Math.max(20, Math.min(300, value));\n        sparkline.push(Math.round(value));\n    }\n    sparkline[sparkline.length - 1] = currentCount;\n    return sparkline;\n}\nfunction determineTrend(sparkline) {\n    const first = sparkline[0];\n    const last = sparkline[sparkline.length - 1];\n    const change = (last - first) / first * 100;\n    let direction;\n    if (change > 10) {\n        direction = \"increasing\";\n    } else if (change < -10) {\n        direction = \"decreasing\";\n    } else {\n        direction = \"stable\";\n    }\n    return {\n        direction,\n        change_percent: parseFloat(Math.abs(change).toFixed(1))\n    };\n}\nfunction formatWaitTime(seconds) {\n    const minutes = Math.round(seconds / 60);\n    if (minutes === 0) return \"<1 minute\";\n    if (minutes === 1) return \"1 minute\";\n    return \"\".concat(minutes, \" minutes\");\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QyxZQUFZLEdBQUcsT0FBTztJQUMxQixJQUFJQSxZQUFZLEdBQUcsT0FBTztJQUMxQixPQUFPLEdBQVcsT0FBUkEsU0FBUTtBQUN0QiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9saWIvbW9ja0RhdGEudHM/NDc0MiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBHYXRlLCBIYWxsLCBDcm93ZFBlcnNvbiwgQWxlcnQgfSBmcm9tICdAL3R5cGVzJztcclxuXHJcbi8vIFNpbXVsYXRlIHJlYWxpc3RpYyBjcm93ZCBkYXRhIGZvciB0aGUgNCBnYXRlc1xyXG5leHBvcnQgZnVuY3Rpb24gc2ltdWxhdGVDcm93ZERhdGEoKTogR2F0ZVtdIHtcclxuICAgIGNvbnN0IGJhc2VUaW1lID0gRGF0ZS5ub3coKTtcclxuXHJcbiAgICAvLyBDcmVhdGUgcmVhbGlzdGljIHZhcmlhdGlvbnMgaW4gY3Jvd2QgbGV2ZWxzXHJcbiAgICBjb25zdCB2YXJpYXRpb24xID0gTWF0aC5zaW4oYmFzZVRpbWUgLyAxMDAwMCkgKiAyMCArIE1hdGgucmFuZG9tKCkgKiAxMDtcclxuICAgIGNvbnN0IHZhcmlhdGlvbjIgPSBNYXRoLmNvcyhiYXNlVGltZSAvIDgwMDApICogMzAgKyBNYXRoLnJhbmRvbSgpICogMTU7XHJcbiAgICBjb25zdCB2YXJpYXRpb24zID0gTWF0aC5zaW4oYmFzZVRpbWUgLyAxMjAwMCkgKiAyNSArIE1hdGgucmFuZG9tKCkgKiAxMjtcclxuICAgIGNvbnN0IHZhcmlhdGlvbjQgPSBNYXRoLmNvcyhiYXNlVGltZSAvIDE1MDAwKSAqIDE4ICsgTWF0aC5yYW5kb20oKSAqIDg7XHJcblxyXG4gICAgY29uc3QgZ2F0ZXM6IEdhdGVbXSA9IFtcclxuICAgICAgICBjcmVhdGVHYXRlKDEsICc0MC43NDk1LC03My45Njg1JywgNDUgKyBNYXRoLnJvdW5kKHZhcmlhdGlvbjEpKSxcclxuICAgICAgICBjcmVhdGVHYXRlKDIsICc0MC43NDg1LC03My45Njc1JywgMjMwICsgTWF0aC5yb3VuZCh2YXJpYXRpb24yKSksXHJcbiAgICAgICAgY3JlYXRlR2F0ZSgzLCAnNDAuNzQ4MywtNzMuOTY5NScsIDEyNSArIE1hdGgucm91bmQodmFyaWF0aW9uMykpLFxyXG4gICAgICAgIGNyZWF0ZUdhdGUoNCwgJzQwLjc0OTMsLTczLjk2NjUnLCAxMTIgKyBNYXRoLnJvdW5kKHZhcmlhdGlvbjQpKSxcclxuICAgIF07XHJcblxyXG4gICAgcmV0dXJuIGdhdGVzO1xyXG59XHJcblxyXG4vLyBTaW11bGF0ZSBoYWxsIGRhdGFcclxuZXhwb3J0IGZ1bmN0aW9uIHNpbXVsYXRlSGFsbERhdGEoKTogSGFsbFtdIHtcclxuICAgIGNvbnN0IGJhc2VUaW1lID0gRGF0ZS5ub3coKTtcclxuXHJcbiAgICBjb25zdCBoYWxsczogSGFsbFtdID0gW1xyXG4gICAgICAgIGNyZWF0ZUhhbGwoMSwgTWF0aC5yb3VuZCgxODAgKyBNYXRoLnNpbihiYXNlVGltZSAvIDUwMDApICogNTApKSxcclxuICAgICAgICBjcmVhdGVIYWxsKDIsIE1hdGgucm91bmQoMzIwICsgTWF0aC5jb3MoYmFzZVRpbWUgLyA2MDAwKSAqIDgwKSksXHJcbiAgICAgICAgY3JlYXRlSGFsbCgzLCBNYXRoLnJvdW5kKDE1MCArIE1hdGguc2luKGJhc2VUaW1lIC8gNzAwMCkgKiA0MCkpLFxyXG4gICAgICAgIGNyZWF0ZUhhbGwoNCwgTWF0aC5yb3VuZCgyODAgKyBNYXRoLmNvcyhiYXNlVGltZSAvIDgwMDApICogNjApKSxcclxuICAgIF07XHJcblxyXG4gICAgcmV0dXJuIGhhbGxzO1xyXG59XHJcblxyXG5mdW5jdGlvbiBjcmVhdGVIYWxsKGhhbGxOdW1iZXI6IG51bWJlciwgY291bnQ6IG51bWJlcik6IEhhbGwge1xyXG4gICAgY29uc3QgY2FwYWNpdHkgPSA0MDA7XHJcbiAgICBjb25zdCBkZW5zaXR5UGVyY2VudCA9IChjb3VudCAvIGNhcGFjaXR5KSAqIDEwMDtcclxuXHJcbiAgICBsZXQgY3Jvd2RMZXZlbDogJ2xvdycgfCAnbWVkaXVtJyB8ICdoaWdoJyB8ICdjcml0aWNhbCc7XHJcbiAgICBsZXQgaGVhdG1hcENvbG9yOiBzdHJpbmc7XHJcbiAgICBsZXQgc3RhbXBlZGVfcmlzazogJ2xvdycgfCAnbWVkaXVtJyB8ICdoaWdoJyB8ICdjcml0aWNhbCc7XHJcblxyXG4gICAgaWYgKGRlbnNpdHlQZXJjZW50IDwgNDApIHtcclxuICAgICAgICBjcm93ZExldmVsID0gJ2xvdyc7XHJcbiAgICAgICAgaGVhdG1hcENvbG9yID0gJyMxMGI5ODEnO1xyXG4gICAgICAgIHN0YW1wZWRlX3Jpc2sgPSAnbG93JztcclxuICAgIH0gZWxzZSBpZiAoZGVuc2l0eVBlcmNlbnQgPCA2MCkge1xyXG4gICAgICAgIGNyb3dkTGV2ZWwgPSAnbWVkaXVtJztcclxuICAgICAgICBoZWF0bWFwQ29sb3IgPSAnI2Y1OWUwYic7XHJcbiAgICAgICAgc3RhbXBlZGVfcmlzayA9ICdsb3cnO1xyXG4gICAgfSBlbHNlIGlmIChkZW5zaXR5UGVyY2VudCA8IDgwKSB7XHJcbiAgICAgICAgY3Jvd2RMZXZlbCA9ICdoaWdoJztcclxuICAgICAgICBoZWF0bWFwQ29sb3IgPSAnI2Y5NzMxNic7XHJcbiAgICAgICAgc3RhbXBlZGVfcmlzayA9ICdtZWRpdW0nO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBjcm93ZExldmVsID0gJ2NyaXRpY2FsJztcclxuICAgICAgICBoZWF0bWFwQ29sb3IgPSAnI2VmNDQ0NCc7XHJcbiAgICAgICAgc3RhbXBlZGVfcmlzayA9ICdoaWdoJztcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGlkOiBgaGFsbC0ke2hhbGxOdW1iZXJ9YCxcclxuICAgICAgICBudW1iZXI6IGhhbGxOdW1iZXIsXHJcbiAgICAgICAgbmFtZTogYEhhbGwgJHtoYWxsTnVtYmVyfWAsXHJcbiAgICAgICAgY2FwYWNpdHksXHJcbiAgICAgICAgY3VycmVudF9jb3VudDogY291bnQsXHJcbiAgICAgICAgZGVuc2l0eV9wZXJjZW50OiBwYXJzZUZsb2F0KGRlbnNpdHlQZXJjZW50LnRvRml4ZWQoMSkpLFxyXG4gICAgICAgIGNyb3dkX2xldmVsOiBjcm93ZExldmVsLFxyXG4gICAgICAgIGhlYXRtYXBfY29sb3I6IGhlYXRtYXBDb2xvcixcclxuICAgICAgICBzdGFtcGVkZV9yaXNrLFxyXG4gICAgfTtcclxufVxyXG5cclxuLy8gSW5pdGlhbGl6ZSBjcm93ZCBzaW11bGF0aW9uIHdpdGggcGVvcGxlXHJcbmV4cG9ydCBmdW5jdGlvbiBpbml0aWFsaXplQ3Jvd2RTaW11bGF0aW9uKGhhbGxDb3VudDogbnVtYmVyID0gNCk6IENyb3dkUGVyc29uW10ge1xyXG4gICAgY29uc3QgcGVvcGxlOiBDcm93ZFBlcnNvbltdID0gW107XHJcbiAgICBjb25zdCB0b3RhbFBlb3BsZSA9IDgwMDtcclxuXHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRvdGFsUGVvcGxlOyBpKyspIHtcclxuICAgICAgICBjb25zdCBoYWxsID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogaGFsbENvdW50KSArIDE7XHJcbiAgICAgICAgY29uc3QgdGFyZ2V0RXhpdCA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDQpICsgMTtcclxuXHJcbiAgICAgICAgLy8gSW5pdGlhbCBwbGFjZW1lbnQgbG9naWNcclxuICAgICAgICBsZXQgeCwgeTtcclxuICAgICAgICBpZiAoaGFsbCA9PT0gMSkgeyAvLyBUb3AgTGVmdFxyXG4gICAgICAgICAgICB4ID0gMTIwICsgTWF0aC5yYW5kb20oKSAqIDI0MDtcclxuICAgICAgICAgICAgeSA9IDEyMCArIE1hdGgucmFuZG9tKCkgKiAyNDA7XHJcbiAgICAgICAgfSBlbHNlIGlmIChoYWxsID09PSAyKSB7IC8vIFRvcCBSaWdodFxyXG4gICAgICAgICAgICB4ID0gNDQwICsgTWF0aC5yYW5kb20oKSAqIDI0MDtcclxuICAgICAgICAgICAgeSA9IDEyMCArIE1hdGgucmFuZG9tKCkgKiAyNDA7XHJcbiAgICAgICAgfSBlbHNlIGlmIChoYWxsID09PSAzKSB7IC8vIEJvdHRvbSBMZWZ0XHJcbiAgICAgICAgICAgIHggPSAxMjAgKyBNYXRoLnJhbmRvbSgpICogMjQwO1xyXG4gICAgICAgICAgICB5ID0gNDQwICsgTWF0aC5yYW5kb20oKSAqIDI0MDtcclxuICAgICAgICB9IGVsc2UgeyAvLyBCb3R0b20gUmlnaHRcclxuICAgICAgICAgICAgeCA9IDQ0MCArIE1hdGgucmFuZG9tKCkgKiAyNDA7XHJcbiAgICAgICAgICAgIHkgPSA0NDAgKyBNYXRoLnJhbmRvbSgpICogMjQwO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcGVvcGxlLnB1c2goe1xyXG4gICAgICAgICAgICBpZDogYHBlcnNvbi0ke2l9YCxcclxuICAgICAgICAgICAgeCxcclxuICAgICAgICAgICAgeSxcclxuICAgICAgICAgICAgdng6IDAsXHJcbiAgICAgICAgICAgIHZ5OiAwLFxyXG4gICAgICAgICAgICBoYWxsLFxyXG4gICAgICAgICAgICB0YXJnZXRFeGl0LFxyXG4gICAgICAgICAgICBzcGVlZDogMC41ICsgTWF0aC5yYW5kb20oKSAqIDAuNSxcclxuICAgICAgICAgICAgc3RhdHVzOiAnaW5faGFsbCcsXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHBlb3BsZTtcclxufVxyXG5cclxuLy8gVXBkYXRlIGNyb3dkIHBvc2l0aW9ucyBmb3IgYW5pbWF0aW9uIHdpdGggc3RydWN0dXJlZCBtb3ZlbWVudFxyXG5leHBvcnQgZnVuY3Rpb24gdXBkYXRlQ3Jvd2RQb3NpdGlvbnMocGVvcGxlOiBDcm93ZFBlcnNvbltdKTogQ3Jvd2RQZXJzb25bXSB7XHJcbiAgICByZXR1cm4gcGVvcGxlLm1hcChwZXJzb24gPT4ge1xyXG4gICAgICAgIGxldCB7IHgsIHksIHN0YXR1cywgdGFyZ2V0RXhpdCwgaGFsbCwgc3BlZWQgfSA9IHBlcnNvbjtcclxuICAgICAgICBsZXQgdnggPSAwO1xyXG4gICAgICAgIGxldCB2eSA9IDA7XHJcblxyXG4gICAgICAgIC8vIFN0cnVjdHVyZWQgTW92ZW1lbnQgTG9naWNcclxuICAgICAgICBpZiAoc3RhdHVzID09PSAnaW5faGFsbCcpIHtcclxuICAgICAgICAgICAgLy8gTW92ZSB0b3dhcmRzIHRoZSBjZW50cmFsIGNvcnJpZG9yIFwiZ2F0ZVwiIG9mIHRoZSBoYWxsXHJcbiAgICAgICAgICAgIC8vIEhhbGwgMSAoVEwpIC0+IFRhcmdldDogKDM4MCwgMjQwKSBvciAoMjQwLCAzODApIGRlcGVuZGluZyBvbiBleGl0P1xyXG4gICAgICAgICAgICAvLyBTaW1wbGlmaWVkOiBBbGwgaGFsbHMgZW1wdHkgaW50byB0aGUgY2VudHJhbCBjcm9zcyBpbnRlcnNlY3Rpb24gYXJlYVxyXG4gICAgICAgICAgICBsZXQgdGFyZ2V0WCA9IDQwMDtcclxuICAgICAgICAgICAgbGV0IHRhcmdldFkgPSA0MDA7XHJcblxyXG4gICAgICAgICAgICBpZiAoaGFsbCA9PT0gMSkgeyB0YXJnZXRYID0gMzcwOyB0YXJnZXRZID0gMzcwOyB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGhhbGwgPT09IDIpIHsgdGFyZ2V0WCA9IDQzMDsgdGFyZ2V0WSA9IDM3MDsgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChoYWxsID09PSAzKSB7IHRhcmdldFggPSAzNzA7IHRhcmdldFkgPSA0MzA7IH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoaGFsbCA9PT0gNCkgeyB0YXJnZXRYID0gNDMwOyB0YXJnZXRZID0gNDMwOyB9XHJcblxyXG4gICAgICAgICAgICAvLyBNb3ZlIHRvd2FyZHMgdGFyZ2V0XHJcbiAgICAgICAgICAgIGNvbnN0IGR4ID0gdGFyZ2V0WCAtIHg7XHJcbiAgICAgICAgICAgIGNvbnN0IGR5ID0gdGFyZ2V0WSAtIHk7XHJcbiAgICAgICAgICAgIGNvbnN0IGRpc3QgPSBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xyXG5cclxuICAgICAgICAgICAgaWYgKGRpc3QgPCAxMCkge1xyXG4gICAgICAgICAgICAgICAgc3RhdHVzID0gJ21lcmdpbmcnO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdnggPSAoZHggLyBkaXN0KSAqIHNwZWVkO1xyXG4gICAgICAgICAgICAgICAgdnkgPSAoZHkgLyBkaXN0KSAqIHNwZWVkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHN0YXR1cyA9PT0gJ21lcmdpbmcnKSB7XHJcbiAgICAgICAgICAgIC8vIE1vdmUgdG8gY2VudGVyIG9mIGNvcnJpZG9yIGxhbmVzXHJcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldFggPSA0MDA7XHJcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldFkgPSA0MDA7XHJcbiAgICAgICAgICAgIGNvbnN0IGR4ID0gdGFyZ2V0WCAtIHg7XHJcbiAgICAgICAgICAgIGNvbnN0IGR5ID0gdGFyZ2V0WSAtIHk7XHJcbiAgICAgICAgICAgIGNvbnN0IGRpc3QgPSBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xyXG5cclxuICAgICAgICAgICAgaWYgKGRpc3QgPCA1KSB7XHJcbiAgICAgICAgICAgICAgICBzdGF0dXMgPSAnaW5fbGFuZSc7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB2eCA9IChkeCAvIGRpc3QpICogc3BlZWQ7XHJcbiAgICAgICAgICAgICAgICB2eSA9IChkeSAvIGRpc3QpICogc3BlZWQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoc3RhdHVzID09PSAnaW5fbGFuZScpIHtcclxuICAgICAgICAgICAgLy8gTW92ZSBhbG9uZyB0aGUgbWFpbiBheGVzIHRvd2FyZHMgdGFyZ2V0IGV4aXRcclxuICAgICAgICAgICAgLy8gRXhpdCAxIChUb3ApOiB4PTM4MC4uNDIwLCB5IC0+IDBcclxuICAgICAgICAgICAgLy8gRXhpdCAyIChSaWdodCk6IHk9MzgwLi40MjAsIHggLT4gODAwXHJcbiAgICAgICAgICAgIC8vIEV4aXQgMyAoQm90dG9tKTogeD0zODAuLjQyMCwgeSAtPiA4MDBcclxuICAgICAgICAgICAgLy8gRXhpdCA0IChMZWZ0KTogeT0zODAuLjQyMCwgeCAtPiAwXHJcblxyXG4gICAgICAgICAgICBpZiAodGFyZ2V0RXhpdCA9PT0gMSkgeyAvLyBUb3BcclxuICAgICAgICAgICAgICAgIGlmIChNYXRoLmFicyh4IC0gNDAwKSA+IDE1KSB7IC8vIENlbnRlciBYIGZpcnN0XHJcbiAgICAgICAgICAgICAgICAgICAgdnggPSAoNDAwIC0geCkgKiAwLjE7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHZ5ID0gLXNwZWVkICogMS41OyAvLyBNb3ZlIFVwXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoeSA8IDUwKSBzdGF0dXMgPSAnYXRfZXhpdCc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodGFyZ2V0RXhpdCA9PT0gMikgeyAvLyBSaWdodFxyXG4gICAgICAgICAgICAgICAgaWYgKE1hdGguYWJzKHkgLSA0MDApID4gMTUpIHsgLy8gQ2VudGVyIFkgZmlyc3RcclxuICAgICAgICAgICAgICAgICAgICB2eSA9ICg0MDAgLSB5KSAqIDAuMTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdnggPSBzcGVlZCAqIDEuNTsgLy8gTW92ZSBSaWdodFxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHggPiA3NTApIHN0YXR1cyA9ICdhdF9leGl0JztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICh0YXJnZXRFeGl0ID09PSAzKSB7IC8vIEJvdHRvbVxyXG4gICAgICAgICAgICAgICAgaWYgKE1hdGguYWJzKHggLSA0MDApID4gMTUpIHtcclxuICAgICAgICAgICAgICAgICAgICB2eCA9ICg0MDAgLSB4KSAqIDAuMTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdnkgPSBzcGVlZCAqIDEuNTsgLy8gTW92ZSBEb3duXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoeSA+IDc1MCkgc3RhdHVzID0gJ2F0X2V4aXQnO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHRhcmdldEV4aXQgPT09IDQpIHsgLy8gTGVmdFxyXG4gICAgICAgICAgICAgICAgaWYgKE1hdGguYWJzKHkgLSA0MDApID4gMTUpIHtcclxuICAgICAgICAgICAgICAgICAgICB2eSA9ICg0MDAgLSB5KSAqIDAuMTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdnggPSAtc3BlZWQgKiAxLjU7IC8vIE1vdmUgTGVmdFxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHggPCA1MCkgc3RhdHVzID0gJ2F0X2V4aXQnO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHN0YXR1cyA9PT0gJ2F0X2V4aXQnKSB7XHJcbiAgICAgICAgICAgIC8vIENvbmdyZWdhdGUgYW5kIG1vdmUgc2xvd2x5IG5lYXIgZXhpdFxyXG4gICAgICAgICAgICAvLyBBZGQgc29tZSBqaXR0ZXIgdG8gbG9vayBsaWtlIGEgY3Jvd2RcclxuICAgICAgICAgICAgdnggPSAoTWF0aC5yYW5kb20oKSAtIDAuNSkgKiAwLjU7XHJcbiAgICAgICAgICAgIHZ5ID0gKE1hdGgucmFuZG9tKCkgLSAwLjUpICogMC41O1xyXG5cclxuICAgICAgICAgICAgLy8gS2VlcCB3aXRoaW4gZXhpdCB6b25lXHJcbiAgICAgICAgICAgIGlmICh0YXJnZXRFeGl0ID09PSAxKSB7IC8vIFRvcFxyXG4gICAgICAgICAgICAgICAgaWYgKHkgPiA2MCkgdnkgLT0gMC4yO1xyXG4gICAgICAgICAgICAgICAgaWYgKHkgPCAxMCkgdnkgKz0gMC4yO1xyXG4gICAgICAgICAgICAgICAgaWYgKHggPCAzNjApIHZ4ICs9IDAuMjtcclxuICAgICAgICAgICAgICAgIGlmICh4ID4gNDQwKSB2eCAtPSAwLjI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodGFyZ2V0RXhpdCA9PT0gMikgeyAvLyBSaWdodFxyXG4gICAgICAgICAgICAgICAgaWYgKHggPCA3NDApIHZ4ICs9IDAuMjtcclxuICAgICAgICAgICAgICAgIGlmICh4ID4gNzkwKSB2eCAtPSAwLjI7XHJcbiAgICAgICAgICAgICAgICBpZiAoeSA8IDM2MCkgdnkgKz0gMC4yO1xyXG4gICAgICAgICAgICAgICAgaWYgKHkgPiA0NDApIHZ5IC09IDAuMjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICh0YXJnZXRFeGl0ID09PSAzKSB7IC8vIEJvdHRvbVxyXG4gICAgICAgICAgICAgICAgaWYgKHkgPCA3NDApIHZ5ICs9IDAuMjtcclxuICAgICAgICAgICAgICAgIGlmICh5ID4gNzkwKSB2eSAtPSAwLjI7XHJcbiAgICAgICAgICAgICAgICBpZiAoeCA8IDM2MCkgdnggKz0gMC4yO1xyXG4gICAgICAgICAgICAgICAgaWYgKHggPiA0NDApIHZ4IC09IDAuMjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICh0YXJnZXRFeGl0ID09PSA0KSB7IC8vIExlZnRcclxuICAgICAgICAgICAgICAgIGlmICh4ID4gNjApIHZ4IC09IDAuMjtcclxuICAgICAgICAgICAgICAgIGlmICh4IDwgMTApIHZ4ICs9IDAuMjtcclxuICAgICAgICAgICAgICAgIGlmICh5IDwgMzYwKSB2eSArPSAwLjI7XHJcbiAgICAgICAgICAgICAgICBpZiAoeSA+IDQ0MCkgdnkgLT0gMC4yO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBPY2Nhc2lvbmFsbHkgcmVzZXQgdG8gaGFsbCB0byBrZWVwIHNpbXVsYXRpb24gZmxvd2luZ1xyXG4gICAgICAgICAgICBpZiAoTWF0aC5yYW5kb20oKSA8IDAuMDA1KSB7XHJcbiAgICAgICAgICAgICAgICBzdGF0dXMgPSAnaW5faGFsbCc7XHJcbiAgICAgICAgICAgICAgICBoYWxsID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogNCkgKyAxO1xyXG4gICAgICAgICAgICAgICAgcGVyc29uLnRhcmdldEV4aXQgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiA0KSArIDE7IC8vIFBpY2sgbmV3IHRhcmdldFxyXG4gICAgICAgICAgICAgICAgLy8gUmVzZXQgcG9zXHJcbiAgICAgICAgICAgICAgICBpZiAoaGFsbCA9PT0gMSkgeyB4ID0gMjAwOyB5ID0gMjAwOyB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChoYWxsID09PSAyKSB7IHggPSA2MDA7IHkgPSAyMDA7IH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGhhbGwgPT09IDMpIHsgeCA9IDIwMDsgeSA9IDYwMDsgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7IHggPSA2MDA7IHkgPSA2MDA7IH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQXBwbHkgbW92ZW1lbnRcclxuICAgICAgICBsZXQgbmV3WCA9IHggKyB2eDtcclxuICAgICAgICBsZXQgbmV3WSA9IHkgKyB2eTtcclxuXHJcbiAgICAgICAgLy8gSGFyZCBib3VuZGFyaWVzIGZvciBtYXBcclxuICAgICAgICBuZXdYID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oODAwLCBuZXdYKSk7XHJcbiAgICAgICAgbmV3WSA9IE1hdGgubWF4KDAsIE1hdGgubWluKDgwMCwgbmV3WSkpO1xyXG5cclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAuLi5wZXJzb24sXHJcbiAgICAgICAgICAgIHg6IG5ld1gsXHJcbiAgICAgICAgICAgIHk6IG5ld1ksXHJcbiAgICAgICAgICAgIHZ4LFxyXG4gICAgICAgICAgICB2eSxcclxuICAgICAgICAgICAgc3RhdHVzLFxyXG4gICAgICAgICAgICBoYWxsXHJcbiAgICAgICAgfTtcclxuICAgIH0pO1xyXG59XHJcblxyXG4vLyBHZW5lcmF0ZSBkeW5hbWljIHJvdXRpbmcgYWxlcnRzXHJcbmV4cG9ydCBmdW5jdGlvbiBnZW5lcmF0ZVJvdXRpbmdBbGVydChnYXRlczogR2F0ZVtdLCBoYWxsczogSGFsbFtdKTogQWxlcnQgfCBudWxsIHtcclxuICAgIGNvbnN0IGJlc3RHYXRlID0gZ2F0ZXMucmVkdWNlKChiZXN0LCBjdXJyZW50KSA9PlxyXG4gICAgICAgIGN1cnJlbnQubWV0cmljcy53YWl0X3RpbWVfc2Vjb25kcyA8IGJlc3QubWV0cmljcy53YWl0X3RpbWVfc2Vjb25kcyA/IGN1cnJlbnQgOiBiZXN0XHJcbiAgICApO1xyXG5cclxuICAgIGNvbnN0IHdvcnN0R2F0ZSA9IGdhdGVzLnJlZHVjZSgod29yc3QsIGN1cnJlbnQpID0+XHJcbiAgICAgICAgY3VycmVudC5tZXRyaWNzLndhaXRfdGltZV9zZWNvbmRzID4gd29yc3QubWV0cmljcy53YWl0X3RpbWVfc2Vjb25kcyA/IGN1cnJlbnQgOiB3b3JzdFxyXG4gICAgKTtcclxuXHJcbiAgICAvLyBDaGVjayBmb3IgaGlnaC1yaXNrIGhhbGxzXHJcbiAgICBjb25zdCBoaWdoUmlza0hhbGxzID0gaGFsbHMuZmlsdGVyKGggPT4gaC5zdGFtcGVkZV9yaXNrID09PSAnaGlnaCcgfHwgaC5zdGFtcGVkZV9yaXNrID09PSAnY3JpdGljYWwnKTtcclxuXHJcbiAgICBpZiAoaGlnaFJpc2tIYWxscy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgaWQ6IGBhbGVydC0ke0RhdGUubm93KCl9YCxcclxuICAgICAgICAgICAgdHlwZTogJ3N0YW1wZWRlJyxcclxuICAgICAgICAgICAgc2V2ZXJpdHk6ICdjcml0aWNhbCcsXHJcbiAgICAgICAgICAgIG1lc3NhZ2U6IGDimqDvuI8gSGlnaCBzdGFtcGVkZSByaXNrIGluICR7aGlnaFJpc2tIYWxscy5tYXAoaCA9PiBoLm5hbWUpLmpvaW4oJywgJyl9ISBBdm9pZCB0aGVzZSBhcmVhcy5gLFxyXG4gICAgICAgICAgICBzdWdnZXN0ZWRFeGl0OiBiZXN0R2F0ZS5nYXRlX251bWJlcixcclxuICAgICAgICAgICAgdGltZXN0YW1wOiBEYXRlLm5vdygpLFxyXG4gICAgICAgICAgICBhY3RpdmU6IHRydWUsXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAod29yc3RHYXRlLmNyb3dkX2xldmVsID09PSAnY3JpdGljYWwnICYmIGJlc3RHYXRlLmNyb3dkX2xldmVsID09PSAnbG93Jykge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGlkOiBgYWxlcnQtJHtEYXRlLm5vdygpfWAsXHJcbiAgICAgICAgICAgIHR5cGU6ICdyb3V0aW5nJyxcclxuICAgICAgICAgICAgc2V2ZXJpdHk6ICdoaWdoJyxcclxuICAgICAgICAgICAgbWVzc2FnZTogYPCfmqggRXhpdCAke3dvcnN0R2F0ZS5nYXRlX251bWJlcn0gaXMgb3ZlcmNyb3dkZWQhIFVzZSBFeGl0ICR7YmVzdEdhdGUuZ2F0ZV9udW1iZXJ9IGluc3RlYWQgKCR7YmVzdEdhdGUubWV0cmljcy53YWl0X3RpbWVfZm9ybWF0dGVkfSB3YWl0KS5gLFxyXG4gICAgICAgICAgICBzdWdnZXN0ZWRFeGl0OiBiZXN0R2F0ZS5nYXRlX251bWJlcixcclxuICAgICAgICAgICAgdGltZXN0YW1wOiBEYXRlLm5vdygpLFxyXG4gICAgICAgICAgICBhY3RpdmU6IHRydWUsXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAod29yc3RHYXRlLmNyb3dkX2xldmVsID09PSAnaGlnaCcgJiYgYmVzdEdhdGUuY3Jvd2RfbGV2ZWwgPT09ICdsb3cnKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgaWQ6IGBhbGVydC0ke0RhdGUubm93KCl9YCxcclxuICAgICAgICAgICAgdHlwZTogJ3JvdXRpbmcnLFxyXG4gICAgICAgICAgICBzZXZlcml0eTogJ21lZGl1bScsXHJcbiAgICAgICAgICAgIG1lc3NhZ2U6IGDwn5KhIEV4aXQgJHtiZXN0R2F0ZS5nYXRlX251bWJlcn0gaGFzIHRoZSBzaG9ydGVzdCB3YWl0IHRpbWUgKCR7YmVzdEdhdGUubWV0cmljcy53YWl0X3RpbWVfZm9ybWF0dGVkfSkuYCxcclxuICAgICAgICAgICAgc3VnZ2VzdGVkRXhpdDogYmVzdEdhdGUuZ2F0ZV9udW1iZXIsXHJcbiAgICAgICAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKSxcclxuICAgICAgICAgICAgYWN0aXZlOiB0cnVlLFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG51bGw7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNyZWF0ZUdhdGUoZ2F0ZU51bWJlcjogbnVtYmVyLCBjb29yZGluYXRlczogc3RyaW5nLCBjb3VudDogbnVtYmVyKTogR2F0ZSB7XHJcbiAgICBjb25zdCBbbGF0LCBsb25dID0gY29vcmRpbmF0ZXMuc3BsaXQoJywnKS5tYXAoTnVtYmVyKTtcclxuXHJcbiAgICAvLyBEZXRlcm1pbmUgY3Jvd2QgbGV2ZWxcclxuICAgIGxldCBjcm93ZExldmVsOiAnbG93JyB8ICdtZWRpdW0nIHwgJ2hpZ2gnIHwgJ2NyaXRpY2FsJztcclxuICAgIGxldCBjcm93ZENvbG9yOiBzdHJpbmc7XHJcblxyXG4gICAgaWYgKGNvdW50IDwgODApIHtcclxuICAgICAgICBjcm93ZExldmVsID0gJ2xvdyc7XHJcbiAgICAgICAgY3Jvd2RDb2xvciA9ICcjMTBiOTgxJztcclxuICAgIH0gZWxzZSBpZiAoY291bnQgPCAxNTApIHtcclxuICAgICAgICBjcm93ZExldmVsID0gJ21lZGl1bSc7XHJcbiAgICAgICAgY3Jvd2RDb2xvciA9ICcjZjU5ZTBiJztcclxuICAgIH0gZWxzZSBpZiAoY291bnQgPCAyMjApIHtcclxuICAgICAgICBjcm93ZExldmVsID0gJ2hpZ2gnO1xyXG4gICAgICAgIGNyb3dkQ29sb3IgPSAnI2Y5NzMxNic7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIGNyb3dkTGV2ZWwgPSAnY3JpdGljYWwnO1xyXG4gICAgICAgIGNyb3dkQ29sb3IgPSAnI2VmNDQ0NCc7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQ2FsY3VsYXRlIG1ldHJpY3NcclxuICAgIGNvbnN0IGRlbnNpdHkgPSBjb3VudCAvIDIwMDtcclxuICAgIGNvbnN0IHdhaXRUaW1lID0gTWF0aC5tYXgoMzAsIGNvdW50ICogMik7XHJcbiAgICBjb25zdCBxdWV1ZUxlbmd0aCA9IGNvdW50ICogMC4wODtcclxuXHJcbiAgICAvLyBHZW5lcmF0ZSB0cmVuZFxyXG4gICAgY29uc3Qgc3BhcmtsaW5lID0gZ2VuZXJhdGVTcGFya2xpbmUoY291bnQpO1xyXG4gICAgY29uc3QgdHJlbmQgPSBkZXRlcm1pbmVUcmVuZChzcGFya2xpbmUpO1xyXG5cclxuICAgIC8vIEdhdGUgbmFtZXNcclxuICAgIGNvbnN0IGdhdGVOYW1lcyA9IFsnTm9ydGggRXhpdCAoRXhpdCAxKScsICdFYXN0IEV4aXQgKEV4aXQgMiknLCAnU291dGggRXhpdCAoRXhpdCAzKScsICdXZXN0IEV4aXQgKEV4aXQgNCknXTtcclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGlkOiBgZ2F0ZS0ke2dhdGVOdW1iZXJ9YCxcclxuICAgICAgICBnYXRlX251bWJlcjogZ2F0ZU51bWJlcixcclxuICAgICAgICBuYW1lOiBnYXRlTmFtZXNbZ2F0ZU51bWJlciAtIDFdLFxyXG4gICAgICAgIGxvY2F0aW9uOiB7IGxhdCwgbG9uIH0sXHJcbiAgICAgICAgc3RhdHVzOiAnYWN0aXZlJyxcclxuICAgICAgICBjcm93ZF9sZXZlbDogY3Jvd2RMZXZlbCxcclxuICAgICAgICBjcm93ZF9jb2xvcjogY3Jvd2RDb2xvcixcclxuICAgICAgICBtZXRyaWNzOiB7XHJcbiAgICAgICAgICAgIHBlb3BsZV9jb3VudDogY291bnQsXHJcbiAgICAgICAgICAgIGRlbnNpdHk6IHBhcnNlRmxvYXQoZGVuc2l0eS50b0ZpeGVkKDIpKSxcclxuICAgICAgICAgICAgZGVuc2l0eV9sZXZlbDogY3Jvd2RMZXZlbCxcclxuICAgICAgICAgICAgd2FpdF90aW1lX3NlY29uZHM6IHdhaXRUaW1lLFxyXG4gICAgICAgICAgICB3YWl0X3RpbWVfZm9ybWF0dGVkOiBmb3JtYXRXYWl0VGltZSh3YWl0VGltZSksXHJcbiAgICAgICAgICAgIHF1ZXVlX2xlbmd0aF9tZXRlcnM6IHBhcnNlRmxvYXQocXVldWVMZW5ndGgudG9GaXhlZCgxKSksXHJcbiAgICAgICAgfSxcclxuICAgICAgICB0cmVuZDoge1xyXG4gICAgICAgICAgICAuLi50cmVuZCxcclxuICAgICAgICAgICAgc3BhcmtsaW5lXHJcbiAgICAgICAgfSxcclxuICAgICAgICBwcmVkaWN0aW9uOiB7XHJcbiAgICAgICAgICAgICc1X21pbl9haGVhZCc6IHtcclxuICAgICAgICAgICAgICAgIGNvdW50OiBNYXRoLnJvdW5kKGNvdW50ICogKDEgKyAoTWF0aC5yYW5kb20oKSAtIDAuNCkgKiAwLjIpKSxcclxuICAgICAgICAgICAgICAgIGNvbmZpZGVuY2U6IDAuODUgKyBNYXRoLnJhbmRvbSgpICogMC4xLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAnMTBfbWluX2FoZWFkJzoge1xyXG4gICAgICAgICAgICAgICAgY291bnQ6IE1hdGgucm91bmQoY291bnQgKiAoMSArIChNYXRoLnJhbmRvbSgpIC0gMC40KSAqIDAuMykpLFxyXG4gICAgICAgICAgICAgICAgY29uZmlkZW5jZTogMC43NSArIE1hdGgucmFuZG9tKCkgKiAwLjEsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgfSxcclxuICAgICAgICBoYXNfYWNjZXNzaWJpbGl0eTogZ2F0ZU51bWJlciA9PT0gMSB8fCBnYXRlTnVtYmVyID09PSAzLFxyXG4gICAgICAgIGVmZmljaWVuY3lfcGVyY2VudDogTWF0aC5yb3VuZCg3MCArIE1hdGgucmFuZG9tKCkgKiAyNSksXHJcbiAgICB9O1xyXG59XHJcblxyXG5mdW5jdGlvbiBnZW5lcmF0ZVNwYXJrbGluZShjdXJyZW50Q291bnQ6IG51bWJlcik6IG51bWJlcltdIHtcclxuICAgIGNvbnN0IHBvaW50cyA9IDEwO1xyXG4gICAgY29uc3Qgc3BhcmtsaW5lOiBudW1iZXJbXSA9IFtdO1xyXG4gICAgbGV0IHZhbHVlID0gY3VycmVudENvdW50IC0gMjA7XHJcblxyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwb2ludHM7IGkrKykge1xyXG4gICAgICAgIHZhbHVlICs9IChNYXRoLnJhbmRvbSgpIC0gMC41KSAqIDEwO1xyXG4gICAgICAgIHZhbHVlID0gTWF0aC5tYXgoMjAsIE1hdGgubWluKDMwMCwgdmFsdWUpKTtcclxuICAgICAgICBzcGFya2xpbmUucHVzaChNYXRoLnJvdW5kKHZhbHVlKSk7XHJcbiAgICB9XHJcblxyXG4gICAgc3BhcmtsaW5lW3NwYXJrbGluZS5sZW5ndGggLSAxXSA9IGN1cnJlbnRDb3VudDtcclxuICAgIHJldHVybiBzcGFya2xpbmU7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGRldGVybWluZVRyZW5kKHNwYXJrbGluZTogbnVtYmVyW10pOiB7XHJcbiAgICBkaXJlY3Rpb246ICdpbmNyZWFzaW5nJyB8ICdzdGFibGUnIHwgJ2RlY3JlYXNpbmcnO1xyXG4gICAgY2hhbmdlX3BlcmNlbnQ6IG51bWJlcjtcclxufSB7XHJcbiAgICBjb25zdCBmaXJzdCA9IHNwYXJrbGluZVswXTtcclxuICAgIGNvbnN0IGxhc3QgPSBzcGFya2xpbmVbc3BhcmtsaW5lLmxlbmd0aCAtIDFdO1xyXG4gICAgY29uc3QgY2hhbmdlID0gKChsYXN0IC0gZmlyc3QpIC8gZmlyc3QpICogMTAwO1xyXG5cclxuICAgIGxldCBkaXJlY3Rpb246ICdpbmNyZWFzaW5nJyB8ICdzdGFibGUnIHwgJ2RlY3JlYXNpbmcnO1xyXG4gICAgaWYgKGNoYW5nZSA+IDEwKSB7XHJcbiAgICAgICAgZGlyZWN0aW9uID0gJ2luY3JlYXNpbmcnO1xyXG4gICAgfSBlbHNlIGlmIChjaGFuZ2UgPCAtMTApIHtcclxuICAgICAgICBkaXJlY3Rpb24gPSAnZGVjcmVhc2luZyc7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIGRpcmVjdGlvbiA9ICdzdGFibGUnO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgZGlyZWN0aW9uLFxyXG4gICAgICAgIGNoYW5nZV9wZXJjZW50OiBwYXJzZUZsb2F0KE1hdGguYWJzKGNoYW5nZSkudG9GaXhlZCgxKSksXHJcbiAgICB9O1xyXG59XHJcblxyXG5mdW5jdGlvbiBmb3JtYXRXYWl0VGltZShzZWNvbmRzOiBudW1iZXIpOiBzdHJpbmcge1xyXG4gICAgY29uc3QgbWludXRlcyA9IE1hdGgucm91bmQoc2Vjb25kcyAvIDYwKTtcclxuICAgIGlmIChtaW51dGVzID09PSAwKSByZXR1cm4gJzwxIG1pbnV0ZSc7XHJcbiAgICBpZiAobWludXRlcyA9PT0gMSkgcmV0dXJuICcxIG1pbnV0ZSc7XHJcbiAgICByZXR1cm4gYCR7bWludXRlc30gbWludXRlc2A7XHJcbn1cclxuIl0sIm5hbWVzIjpbInNpbXVsYXRlQ3Jvd2REYXRhIiwiYmFzZVRpbWUiLCJEYXRlIiwibm93IiwidmFyaWF0aW9uMSIsIk1hdGgiLCJzaW4iLCJyYW5kb20iLCJ2YXJpYXRpb24yIiwiY29zIiwidmFyaWF0aW9uMyIsInZhcmlhdGlvbjQiLCJnYXRlcyIsImNyZWF0ZUdhdGUiLCJyb3VuZCIsInNpbXVsYXRlSGFsbERhdGEiLCJoYWxscyIsImNyZWF0ZUhhbGwiLCJoYWxsTnVtYmVyIiwiY291bnQiLCJjYXBhY2l0eSIsImRlbnNpdHlQZXJjZW50IiwiY3Jvd2RMZXZlbCIsImhlYXRtYXBDb2xvciIsInN0YW1wZWRlX3Jpc2siLCJpZCIsIm51bWJlciIsIm5hbWUiLCJjdXJyZW50X2NvdW50IiwiZGVuc2l0eV9wZXJjZW50IiwicGFyc2VGbG9hdCIsInRvRml4ZWQiLCJjcm93ZF9sZXZlbCIsImhlYXRtYXBfY29sb3IiLCJpbml0aWFsaXplQ3Jvd2RTaW11bGF0aW9uIiwiaGFsbENvdW50IiwicGVvcGxlIiwidG90YWxQZW9wbGUiLCJpIiwiaGFsbCIsImZsb29yIiwidGFyZ2V0RXhpdCIsIngiLCJ5IiwicHVzaCIsInZ4IiwidnkiLCJzcGVlZCIsInN0YXR1cyIsInVwZGF0ZUNyb3dkUG9zaXRpb25zIiwibWFwIiwicGVyc29uIiwidGFyZ2V0WCIsInRhcmdldFkiLCJkeCIsImR5IiwiZGlzdCIsInNxcnQiLCJhYnMiLCJuZXdYIiwibmV3WSIsIm1heCIsIm1pbiIsImdlbmVyYXRlUm91dGluZ0FsZXJ0IiwiYmVzdEdhdGUiLCJyZWR1Y2UiLCJiZXN0IiwiY3VycmVudCIsIm1ldHJpY3MiLCJ3YWl0X3RpbWVfc2Vjb25kcyIsIndvcnN0R2F0ZSIsIndvcnN0IiwiaGlnaFJpc2tIYWxscyIsImZpbHRlciIsImgiLCJsZW5ndGgiLCJ0eXBlIiwic2V2ZXJpdHkiLCJtZXNzYWdlIiwiam9pbiIsInN1Z2dlc3RlZEV4aXQiLCJnYXRlX251bWJlciIsInRpbWVzdGFtcCIsImFjdGl2ZSIsIndhaXRfdGltZV9mb3JtYXR0ZWQiLCJnYXRlTnVtYmVyIiwiY29vcmRpbmF0ZXMiLCJsYXQiLCJsb24iLCJzcGxpdCIsIk51bWJlciIsImNyb3dkQ29sb3IiLCJkZW5zaXR5Iiwid2FpdFRpbWUiLCJxdWV1ZUxlbmd0aCIsInNwYXJrbGluZSIsImdlbmVyYXRlU3BhcmtsaW5lIiwidHJlbmQiLCJkZXRlcm1pbmVUcmVuZCIsImdhdGVOYW1lcyIsImxvY2F0aW9uIiwiY3Jvd2RfY29sb3IiLCJwZW9wbGVfY291bnQiLCJkZW5zaXR5X2xldmVsIiwiZm9ybWF0V2FpdFRpbWUiLCJxdWV1ZV9sZW5ndGhfbWV0ZXJzIiwicHJlZGljdGlvbiIsImNvbmZpZGVuY2UiLCJoYXNfYWNjZXNzaWJpbGl0eSIsImVmZmljaWVuY3lfcGVyY2VudCIsImN1cnJlbnRDb3VudCIsInBvaW50cyIsInZhbHVlIiwiZmlyc3QiLCJsYXN0IiwiY2hhbmdlIiwiZGlyZWN0aW9uIiwiY2hhbmdlX3BlcmNlbnQiLCJzZWNvbmRzIiwibWludXRlcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/mockData.ts\n"));

/***/ })

});