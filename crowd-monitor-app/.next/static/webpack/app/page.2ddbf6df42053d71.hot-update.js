"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./lib/mockData.ts":
/*!*************************!*\
  !*** ./lib/mockData.ts ***!
  \*************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   generateRoutingAlert: function() { return /* binding */ generateRoutingAlert; },\n/* harmony export */   initializeCrowdSimulation: function() { return /* binding */ initializeCrowdSimulation; },\n/* harmony export */   simulateCrowdData: function() { return /* binding */ simulateCrowdData; },\n/* harmony export */   simulateHallData: function() { return /* binding */ simulateHallData; },\n/* harmony export */   updateCrowdPositions: function() { return /* binding */ updateCrowdPositions; }\n/* harmony export */ });\n// Simulate realistic crowd data for the 4 gates\nfunction simulateCrowdData() {\n    const baseTime = Date.now();\n    // Create realistic variations in crowd levels\n    const variation1 = Math.sin(baseTime / 10000) * 20 + Math.random() * 10;\n    const variation2 = Math.cos(baseTime / 8000) * 30 + Math.random() * 15;\n    const variation3 = Math.sin(baseTime / 12000) * 25 + Math.random() * 12;\n    const variation4 = Math.cos(baseTime / 15000) * 18 + Math.random() * 8;\n    const gates = [\n        createGate(1, \"40.7495,-73.9685\", 45 + Math.round(variation1)),\n        createGate(2, \"40.7485,-73.9675\", 230 + Math.round(variation2)),\n        createGate(3, \"40.7483,-73.9695\", 125 + Math.round(variation3)),\n        createGate(4, \"40.7493,-73.9665\", 112 + Math.round(variation4))\n    ];\n    return gates;\n}\n// Simulate hall data\nfunction simulateHallData() {\n    const baseTime = Date.now();\n    const halls = [\n        createHall(1, Math.round(180 + Math.sin(baseTime / 5000) * 50)),\n        createHall(2, Math.round(320 + Math.cos(baseTime / 6000) * 80)),\n        createHall(3, Math.round(150 + Math.sin(baseTime / 7000) * 40)),\n        createHall(4, Math.round(280 + Math.cos(baseTime / 8000) * 60))\n    ];\n    return halls;\n}\nfunction createHall(hallNumber, count) {\n    const capacity = 400;\n    const densityPercent = count / capacity * 100;\n    let crowdLevel;\n    let heatmapColor;\n    let stampede_risk;\n    if (densityPercent < 40) {\n        crowdLevel = \"low\";\n        heatmapColor = \"#10b981\";\n        stampede_risk = \"low\";\n    } else if (densityPercent < 60) {\n        crowdLevel = \"medium\";\n        heatmapColor = \"#f59e0b\";\n        stampede_risk = \"low\";\n    } else if (densityPercent < 80) {\n        crowdLevel = \"high\";\n        heatmapColor = \"#f97316\";\n        stampede_risk = \"medium\";\n    } else {\n        crowdLevel = \"critical\";\n        heatmapColor = \"#ef4444\";\n        stampede_risk = \"high\";\n    }\n    return {\n        id: \"hall-\".concat(hallNumber),\n        number: hallNumber,\n        name: \"Hall \".concat(hallNumber),\n        capacity,\n        current_count: count,\n        density_percent: parseFloat(densityPercent.toFixed(1)),\n        crowd_level: crowdLevel,\n        heatmap_color: heatmapColor,\n        stampede_risk\n    };\n}\n// Initialize crowd simulation with people\nfunction initializeCrowdSimulation() {\n    let hallCount = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 4;\n    const people = [];\n    const totalPeople = 800;\n    for(let i = 0; i < totalPeople; i++){\n        const hall = Math.floor(Math.random() * hallCount) + 1;\n        const targetExit = Math.floor(Math.random() * 4) + 1;\n        // Initial placement logic\n        let x, y;\n        if (hall === 1) {\n            x = 120 + Math.random() * 240;\n            y = 120 + Math.random() * 240;\n        } else if (hall === 2) {\n            x = 440 + Math.random() * 240;\n            y = 120 + Math.random() * 240;\n        } else if (hall === 3) {\n            x = 120 + Math.random() * 240;\n            y = 440 + Math.random() * 240;\n        } else {\n            x = 440 + Math.random() * 240;\n            y = 440 + Math.random() * 240;\n        }\n        people.push({\n            id: \"person-\".concat(i),\n            x,\n            y,\n            vx: 0,\n            vy: 0,\n            hall,\n            targetExit,\n            speed: 0.5 + Math.random() * 0.5,\n            status: \"in_hall\"\n        });\n    }\n    return people;\n}\n// Update crowd positions for animation with structured movement\nfunction updateCrowdPositions(people) {\n    return people.map((person)=>{\n        let { x, y, status, targetExit, hall, speed } = person;\n        let vx = 0;\n        let vy = 0;\n        // Structured Movement Logic\n        if (status === \"in_hall\") {\n            // Move towards the central corridor \"gate\" of the hall\n            // Hall 1 (TL) -> Target: (380, 240) or (240, 380) depending on exit?\n            // Simplified: All halls empty into the central cross intersection area\n            let targetX = 400;\n            let targetY = 400;\n            if (hall === 1) {\n                targetX = 370;\n                targetY = 370;\n            } else if (hall === 2) {\n                targetX = 430;\n                targetY = 370;\n            } else if (hall === 3) {\n                targetX = 370;\n                targetY = 430;\n            } else if (hall === 4) {\n                targetX = 430;\n                targetY = 430;\n            }\n            // Move towards target\n            const dx = targetX - x;\n            const dy = targetY - y;\n            const dist = Math.sqrt(dx * dx + dy * dy);\n            if (dist < 10) {\n                status = \"merging\";\n            } else {\n                vx = dx / dist * speed;\n                vy = dy / dist * speed;\n            }\n        } else if (status === \"merging\") {\n            // Move to center of corridor lanes\n            const targetX = 400;\n            const targetY = 400;\n            const dx = targetX - x;\n            const dy = targetY - y;\n            const dist = Math.sqrt(dx * dx + dy * dy);\n            if (dist < 5) {\n                status = \"in_lane\";\n            } else {\n                vx = dx / dist * speed;\n                vy = dy / dist * speed;\n            }\n        } else if (status === \"in_lane\") {\n            // Move along the main axes towards target exit\n            // Exit 1 (Top): x=380..420, y -> 0\n            // Exit 2 (Right): y=380..420, x -> 800\n            // Exit 3 (Bottom): x=380..420, y -> 800\n            // Exit 4 (Left): y=380..420, x -> 0\n            if (targetExit === 1) {\n                if (Math.abs(x - 400) > 15) {\n                    vx = (400 - x) * 0.1;\n                } else {\n                    vy = -speed * 1.5; // Move Up\n                }\n                if (y < 50) status = \"at_exit\";\n            } else if (targetExit === 2) {\n                if (Math.abs(y - 400) > 15) {\n                    vy = (400 - y) * 0.1;\n                } else {\n                    vx = speed * 1.5; // Move Right\n                }\n                if (x > 750) status = \"at_exit\";\n            } else if (targetExit === 3) {\n                if (Math.abs(x - 400) > 15) {\n                    vx = (400 - x) * 0.1;\n                } else {\n                    vy = speed * 1.5; // Move Down\n                }\n                if (y > 750) status = \"at_exit\";\n            } else if (targetExit === 4) {\n                if (Math.abs(y - 400) > 15) {\n                    vy = (400 - y) * 0.1;\n                } else {\n                    vx = -speed * 1.5; // Move Left\n                }\n                if (x < 50) status = \"at_exit\";\n            }\n        } else if (status === \"at_exit\") {\n            // Congregate and move slowly near exit\n            // Add some jitter to look like a crowd\n            vx = (Math.random() - 0.5) * 0.5;\n            vy = (Math.random() - 0.5) * 0.5;\n            // Keep within exit zone\n            if (targetExit === 1) {\n                if (y > 60) vy -= 0.2;\n                if (y < 10) vy += 0.2;\n                if (x < 360) vx += 0.2;\n                if (x > 440) vx -= 0.2;\n            } else if (targetExit === 2) {\n                if (x < 740) vx += 0.2;\n                if (x > 790) vx -= 0.2;\n                if (y < 360) vy += 0.2;\n                if (y > 440) vy -= 0.2;\n            } else if (targetExit === 3) {\n                if (y < 740) vy += 0.2;\n                if (y > 790) vy -= 0.2;\n                if (x < 360) vx += 0.2;\n                if (x > 440) vx -= 0.2;\n            } else if (targetExit === 4) {\n                if (x > 60) vx -= 0.2;\n                if (x < 10) vx += 0.2;\n                if (y < 360) vy += 0.2;\n                if (y > 440) vy -= 0.2;\n            }\n            // Occasionally reset to hall to keep simulation flowing\n            if (Math.random() < 0.005) {\n                status = \"in_hall\";\n                hall = Math.floor(Math.random() * 4) + 1;\n                person.targetExit = Math.floor(Math.random() * 4) + 1; // Pick new target\n                // Reset pos\n                if (hall === 1) {\n                    x = 200;\n                    y = 200;\n                } else if (hall === 2) {\n                    x = 600;\n                    y = 200;\n                } else if (hall === 3) {\n                    x = 200;\n                    y = 600;\n                } else {\n                    x = 600;\n                    y = 600;\n                }\n            }\n        }\n        // Apply movement\n        let newX = x + vx;\n        let newY = y + vy;\n        // Hard boundaries for map\n        newX = Math.max(0, Math.min(800, newX));\n        newY = Math.max(0, Math.min(800, newY));\n        return {\n            ...person,\n            x: newX,\n            y: newY,\n            vx,\n            vy,\n            status,\n            hall\n        };\n    });\n}\n// Generate dynamic routing alerts\nfunction generateRoutingAlert(gates, halls) {\n    const bestGate = gates.reduce((best, current)=>current.metrics.wait_time_seconds < best.metrics.wait_time_seconds ? current : best);\n    const worstGate = gates.reduce((worst, current)=>current.metrics.wait_time_seconds > worst.metrics.wait_time_seconds ? current : worst);\n    // Check for high-risk halls\n    const highRiskHalls = halls.filter((h)=>h.stampede_risk === \"high\" || h.stampede_risk === \"critical\");\n    if (highRiskHalls.length > 0) {\n        return {\n            id: \"alert-\".concat(Date.now()),\n            type: \"stampede\",\n            severity: \"critical\",\n            message: \"⚠️ High stampede risk in \".concat(highRiskHalls.map((h)=>h.name).join(\", \"), \"! Avoid these areas.\"),\n            suggestedExit: bestGate.gate_number,\n            timestamp: Date.now(),\n            active: true\n        };\n    }\n    if (worstGate.crowd_level === \"critical\" && bestGate.crowd_level === \"low\") {\n        return {\n            id: \"alert-\".concat(Date.now()),\n            type: \"routing\",\n            severity: \"high\",\n            message: \"\\uD83D\\uDEA8 Exit \".concat(worstGate.gate_number, \" is overcrowded! Use Exit \").concat(bestGate.gate_number, \" instead (\").concat(bestGate.metrics.wait_time_formatted, \" wait).\"),\n            suggestedExit: bestGate.gate_number,\n            timestamp: Date.now(),\n            active: true\n        };\n    }\n    if (worstGate.crowd_level === \"high\" && bestGate.crowd_level === \"low\") {\n        return {\n            id: \"alert-\".concat(Date.now()),\n            type: \"routing\",\n            severity: \"medium\",\n            message: \"\\uD83D\\uDCA1 Exit \".concat(bestGate.gate_number, \" has the shortest wait time (\").concat(bestGate.metrics.wait_time_formatted, \").\"),\n            suggestedExit: bestGate.gate_number,\n            timestamp: Date.now(),\n            active: true\n        };\n    }\n    return null;\n}\nfunction createGate(gateNumber, coordinates, count) {\n    const [lat, lon] = coordinates.split(\",\").map(Number);\n    // Determine crowd level\n    let crowdLevel;\n    let crowdColor;\n    if (count < 80) {\n        crowdLevel = \"low\";\n        crowdColor = \"#10b981\";\n    } else if (count < 150) {\n        crowdLevel = \"medium\";\n        crowdColor = \"#f59e0b\";\n    } else if (count < 220) {\n        crowdLevel = \"high\";\n        crowdColor = \"#f97316\";\n    } else {\n        crowdLevel = \"critical\";\n        crowdColor = \"#ef4444\";\n    }\n    // Calculate metrics\n    const density = count / 200;\n    const waitTime = Math.max(30, count * 2);\n    const queueLength = count * 0.08;\n    // Generate trend\n    const sparkline = generateSparkline(count);\n    const trend = determineTrend(sparkline);\n    // Gate names\n    const gateNames = [\n        \"North Exit (Exit 1)\",\n        \"East Exit (Exit 2)\",\n        \"South Exit (Exit 3)\",\n        \"West Exit (Exit 4)\"\n    ];\n    return {\n        id: \"gate-\".concat(gateNumber),\n        gate_number: gateNumber,\n        name: gateNames[gateNumber - 1],\n        location: {\n            lat,\n            lon\n        },\n        status: \"active\",\n        crowd_level: crowdLevel,\n        crowd_color: crowdColor,\n        metrics: {\n            people_count: count,\n            density: parseFloat(density.toFixed(2)),\n            density_level: crowdLevel,\n            wait_time_seconds: waitTime,\n            wait_time_formatted: formatWaitTime(waitTime),\n            queue_length_meters: parseFloat(queueLength.toFixed(1))\n        },\n        trend,\n        prediction: {\n            \"5_min_ahead\": {\n                count: Math.round(count * (1 + (Math.random() - 0.4) * 0.2)),\n                confidence: 0.85 + Math.random() * 0.1\n            },\n            \"10_min_ahead\": {\n                count: Math.round(count * (1 + (Math.random() - 0.4) * 0.3)),\n                confidence: 0.75 + Math.random() * 0.1\n            }\n        },\n        has_accessibility: gateNumber === 1 || gateNumber === 3,\n        efficiency_percent: Math.round(70 + Math.random() * 25)\n    };\n}\nfunction generateSparkline(currentCount) {\n    const points = 10;\n    const sparkline = [];\n    let value = currentCount - 20;\n    for(let i = 0; i < points; i++){\n        value += (Math.random() - 0.5) * 10;\n        value = Math.max(20, Math.min(300, value));\n        sparkline.push(Math.round(value));\n    }\n    sparkline[sparkline.length - 1] = currentCount;\n    return sparkline;\n}\nfunction determineTrend(sparkline) {\n    const first = sparkline[0];\n    const last = sparkline[sparkline.length - 1];\n    const change = (last - first) / first * 100;\n    let direction;\n    if (change > 10) {\n        direction = \"increasing\";\n    } else if (change < -10) {\n        direction = \"decreasing\";\n    } else {\n        direction = \"stable\";\n    }\n    return {\n        direction,\n        change_percent: parseFloat(Math.abs(change).toFixed(1))\n    };\n}\nfunction formatWaitTime(seconds) {\n    const minutes = Math.round(seconds / 60);\n    if (minutes === 0) return \"<1 minute\";\n    if (minutes === 1) return \"1 minute\";\n    return \"\".concat(minutes, \" minutes\");\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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WSxHQUFHLE9BQU87SUFDMUIsT0FBTyxHQUFXLE9BQVJBLFNBQVE7QUFDdEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbGliL21vY2tEYXRhLnRzPzQ3NDIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgR2F0ZSwgSGFsbCwgQ3Jvd2RQZXJzb24sIEFsZXJ0IH0gZnJvbSAnQC90eXBlcyc7XHJcblxyXG4vLyBTaW11bGF0ZSByZWFsaXN0aWMgY3Jvd2QgZGF0YSBmb3IgdGhlIDQgZ2F0ZXNcclxuZXhwb3J0IGZ1bmN0aW9uIHNpbXVsYXRlQ3Jvd2REYXRhKCk6IEdhdGVbXSB7XHJcbiAgICBjb25zdCBiYXNlVGltZSA9IERhdGUubm93KCk7XHJcblxyXG4gICAgLy8gQ3JlYXRlIHJlYWxpc3RpYyB2YXJpYXRpb25zIGluIGNyb3dkIGxldmVsc1xyXG4gICAgY29uc3QgdmFyaWF0aW9uMSA9IE1hdGguc2luKGJhc2VUaW1lIC8gMTAwMDApICogMjAgKyBNYXRoLnJhbmRvbSgpICogMTA7XHJcbiAgICBjb25zdCB2YXJpYXRpb24yID0gTWF0aC5jb3MoYmFzZVRpbWUgLyA4MDAwKSAqIDMwICsgTWF0aC5yYW5kb20oKSAqIDE1O1xyXG4gICAgY29uc3QgdmFyaWF0aW9uMyA9IE1hdGguc2luKGJhc2VUaW1lIC8gMTIwMDApICogMjUgKyBNYXRoLnJhbmRvbSgpICogMTI7XHJcbiAgICBjb25zdCB2YXJpYXRpb240ID0gTWF0aC5jb3MoYmFzZVRpbWUgLyAxNTAwMCkgKiAxOCArIE1hdGgucmFuZG9tKCkgKiA4O1xyXG5cclxuICAgIGNvbnN0IGdhdGVzOiBHYXRlW10gPSBbXHJcbiAgICAgICAgY3JlYXRlR2F0ZSgxLCAnNDAuNzQ5NSwtNzMuOTY4NScsIDQ1ICsgTWF0aC5yb3VuZCh2YXJpYXRpb24xKSksXHJcbiAgICAgICAgY3JlYXRlR2F0ZSgyLCAnNDAuNzQ4NSwtNzMuOTY3NScsIDIzMCArIE1hdGgucm91bmQodmFyaWF0aW9uMikpLFxyXG4gICAgICAgIGNyZWF0ZUdhdGUoMywgJzQwLjc0ODMsLTczLjk2OTUnLCAxMjUgKyBNYXRoLnJvdW5kKHZhcmlhdGlvbjMpKSxcclxuICAgICAgICBjcmVhdGVHYXRlKDQsICc0MC43NDkzLC03My45NjY1JywgMTEyICsgTWF0aC5yb3VuZCh2YXJpYXRpb240KSksXHJcbiAgICBdO1xyXG5cclxuICAgIHJldHVybiBnYXRlcztcclxufVxyXG5cclxuLy8gU2ltdWxhdGUgaGFsbCBkYXRhXHJcbmV4cG9ydCBmdW5jdGlvbiBzaW11bGF0ZUhhbGxEYXRhKCk6IEhhbGxbXSB7XHJcbiAgICBjb25zdCBiYXNlVGltZSA9IERhdGUubm93KCk7XHJcblxyXG4gICAgY29uc3QgaGFsbHM6IEhhbGxbXSA9IFtcclxuICAgICAgICBjcmVhdGVIYWxsKDEsIE1hdGgucm91bmQoMTgwICsgTWF0aC5zaW4oYmFzZVRpbWUgLyA1MDAwKSAqIDUwKSksXHJcbiAgICAgICAgY3JlYXRlSGFsbCgyLCBNYXRoLnJvdW5kKDMyMCArIE1hdGguY29zKGJhc2VUaW1lIC8gNjAwMCkgKiA4MCkpLFxyXG4gICAgICAgIGNyZWF0ZUhhbGwoMywgTWF0aC5yb3VuZCgxNTAgKyBNYXRoLnNpbihiYXNlVGltZSAvIDcwMDApICogNDApKSxcclxuICAgICAgICBjcmVhdGVIYWxsKDQsIE1hdGgucm91bmQoMjgwICsgTWF0aC5jb3MoYmFzZVRpbWUgLyA4MDAwKSAqIDYwKSksXHJcbiAgICBdO1xyXG5cclxuICAgIHJldHVybiBoYWxscztcclxufVxyXG5cclxuZnVuY3Rpb24gY3JlYXRlSGFsbChoYWxsTnVtYmVyOiBudW1iZXIsIGNvdW50OiBudW1iZXIpOiBIYWxsIHtcclxuICAgIGNvbnN0IGNhcGFjaXR5ID0gNDAwO1xyXG4gICAgY29uc3QgZGVuc2l0eVBlcmNlbnQgPSAoY291bnQgLyBjYXBhY2l0eSkgKiAxMDA7XHJcblxyXG4gICAgbGV0IGNyb3dkTGV2ZWw6ICdsb3cnIHwgJ21lZGl1bScgfCAnaGlnaCcgfCAnY3JpdGljYWwnO1xyXG4gICAgbGV0IGhlYXRtYXBDb2xvcjogc3RyaW5nO1xyXG4gICAgbGV0IHN0YW1wZWRlX3Jpc2s6ICdsb3cnIHwgJ21lZGl1bScgfCAnaGlnaCcgfCAnY3JpdGljYWwnO1xyXG5cclxuICAgIGlmIChkZW5zaXR5UGVyY2VudCA8IDQwKSB7XHJcbiAgICAgICAgY3Jvd2RMZXZlbCA9ICdsb3cnO1xyXG4gICAgICAgIGhlYXRtYXBDb2xvciA9ICcjMTBiOTgxJztcclxuICAgICAgICBzdGFtcGVkZV9yaXNrID0gJ2xvdyc7XHJcbiAgICB9IGVsc2UgaWYgKGRlbnNpdHlQZXJjZW50IDwgNjApIHtcclxuICAgICAgICBjcm93ZExldmVsID0gJ21lZGl1bSc7XHJcbiAgICAgICAgaGVhdG1hcENvbG9yID0gJyNmNTllMGInO1xyXG4gICAgICAgIHN0YW1wZWRlX3Jpc2sgPSAnbG93JztcclxuICAgIH0gZWxzZSBpZiAoZGVuc2l0eVBlcmNlbnQgPCA4MCkge1xyXG4gICAgICAgIGNyb3dkTGV2ZWwgPSAnaGlnaCc7XHJcbiAgICAgICAgaGVhdG1hcENvbG9yID0gJyNmOTczMTYnO1xyXG4gICAgICAgIHN0YW1wZWRlX3Jpc2sgPSAnbWVkaXVtJztcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgY3Jvd2RMZXZlbCA9ICdjcml0aWNhbCc7XHJcbiAgICAgICAgaGVhdG1hcENvbG9yID0gJyNlZjQ0NDQnO1xyXG4gICAgICAgIHN0YW1wZWRlX3Jpc2sgPSAnaGlnaCc7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBpZDogYGhhbGwtJHtoYWxsTnVtYmVyfWAsXHJcbiAgICAgICAgbnVtYmVyOiBoYWxsTnVtYmVyLFxyXG4gICAgICAgIG5hbWU6IGBIYWxsICR7aGFsbE51bWJlcn1gLFxyXG4gICAgICAgIGNhcGFjaXR5LFxyXG4gICAgICAgIGN1cnJlbnRfY291bnQ6IGNvdW50LFxyXG4gICAgICAgIGRlbnNpdHlfcGVyY2VudDogcGFyc2VGbG9hdChkZW5zaXR5UGVyY2VudC50b0ZpeGVkKDEpKSxcclxuICAgICAgICBjcm93ZF9sZXZlbDogY3Jvd2RMZXZlbCxcclxuICAgICAgICBoZWF0bWFwX2NvbG9yOiBoZWF0bWFwQ29sb3IsXHJcbiAgICAgICAgc3RhbXBlZGVfcmlzayxcclxuICAgIH07XHJcbn1cclxuXHJcbi8vIEluaXRpYWxpemUgY3Jvd2Qgc2ltdWxhdGlvbiB3aXRoIHBlb3BsZVxyXG5leHBvcnQgZnVuY3Rpb24gaW5pdGlhbGl6ZUNyb3dkU2ltdWxhdGlvbihoYWxsQ291bnQ6IG51bWJlciA9IDQpOiBDcm93ZFBlcnNvbltdIHtcclxuICAgIGNvbnN0IHBlb3BsZTogQ3Jvd2RQZXJzb25bXSA9IFtdO1xyXG4gICAgY29uc3QgdG90YWxQZW9wbGUgPSA4MDA7XHJcblxyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0b3RhbFBlb3BsZTsgaSsrKSB7XHJcbiAgICAgICAgY29uc3QgaGFsbCA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIGhhbGxDb3VudCkgKyAxO1xyXG4gICAgICAgIGNvbnN0IHRhcmdldEV4aXQgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiA0KSArIDE7XHJcblxyXG4gICAgICAgIC8vIEluaXRpYWwgcGxhY2VtZW50IGxvZ2ljXHJcbiAgICAgICAgbGV0IHgsIHk7XHJcbiAgICAgICAgaWYgKGhhbGwgPT09IDEpIHsgLy8gVG9wIExlZnRcclxuICAgICAgICAgICAgeCA9IDEyMCArIE1hdGgucmFuZG9tKCkgKiAyNDA7XHJcbiAgICAgICAgICAgIHkgPSAxMjAgKyBNYXRoLnJhbmRvbSgpICogMjQwO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoaGFsbCA9PT0gMikgeyAvLyBUb3AgUmlnaHRcclxuICAgICAgICAgICAgeCA9IDQ0MCArIE1hdGgucmFuZG9tKCkgKiAyNDA7XHJcbiAgICAgICAgICAgIHkgPSAxMjAgKyBNYXRoLnJhbmRvbSgpICogMjQwO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoaGFsbCA9PT0gMykgeyAvLyBCb3R0b20gTGVmdFxyXG4gICAgICAgICAgICB4ID0gMTIwICsgTWF0aC5yYW5kb20oKSAqIDI0MDtcclxuICAgICAgICAgICAgeSA9IDQ0MCArIE1hdGgucmFuZG9tKCkgKiAyNDA7XHJcbiAgICAgICAgfSBlbHNlIHsgLy8gQm90dG9tIFJpZ2h0XHJcbiAgICAgICAgICAgIHggPSA0NDAgKyBNYXRoLnJhbmRvbSgpICogMjQwO1xyXG4gICAgICAgICAgICB5ID0gNDQwICsgTWF0aC5yYW5kb20oKSAqIDI0MDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHBlb3BsZS5wdXNoKHtcclxuICAgICAgICAgICAgaWQ6IGBwZXJzb24tJHtpfWAsXHJcbiAgICAgICAgICAgIHgsXHJcbiAgICAgICAgICAgIHksXHJcbiAgICAgICAgICAgIHZ4OiAwLFxyXG4gICAgICAgICAgICB2eTogMCxcclxuICAgICAgICAgICAgaGFsbCxcclxuICAgICAgICAgICAgdGFyZ2V0RXhpdCxcclxuICAgICAgICAgICAgc3BlZWQ6IDAuNSArIE1hdGgucmFuZG9tKCkgKiAwLjUsXHJcbiAgICAgICAgICAgIHN0YXR1czogJ2luX2hhbGwnLFxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBwZW9wbGU7XHJcbn1cclxuXHJcbi8vIFVwZGF0ZSBjcm93ZCBwb3NpdGlvbnMgZm9yIGFuaW1hdGlvbiB3aXRoIHN0cnVjdHVyZWQgbW92ZW1lbnRcclxuZXhwb3J0IGZ1bmN0aW9uIHVwZGF0ZUNyb3dkUG9zaXRpb25zKHBlb3BsZTogQ3Jvd2RQZXJzb25bXSk6IENyb3dkUGVyc29uW10ge1xyXG4gICAgcmV0dXJuIHBlb3BsZS5tYXAocGVyc29uID0+IHtcclxuICAgICAgICBsZXQgeyB4LCB5LCBzdGF0dXMsIHRhcmdldEV4aXQsIGhhbGwsIHNwZWVkIH0gPSBwZXJzb247XHJcbiAgICAgICAgbGV0IHZ4ID0gMDtcclxuICAgICAgICBsZXQgdnkgPSAwO1xyXG5cclxuICAgICAgICAvLyBTdHJ1Y3R1cmVkIE1vdmVtZW50IExvZ2ljXHJcbiAgICAgICAgaWYgKHN0YXR1cyA9PT0gJ2luX2hhbGwnKSB7XHJcbiAgICAgICAgICAgIC8vIE1vdmUgdG93YXJkcyB0aGUgY2VudHJhbCBjb3JyaWRvciBcImdhdGVcIiBvZiB0aGUgaGFsbFxyXG4gICAgICAgICAgICAvLyBIYWxsIDEgKFRMKSAtPiBUYXJnZXQ6ICgzODAsIDI0MCkgb3IgKDI0MCwgMzgwKSBkZXBlbmRpbmcgb24gZXhpdD9cclxuICAgICAgICAgICAgLy8gU2ltcGxpZmllZDogQWxsIGhhbGxzIGVtcHR5IGludG8gdGhlIGNlbnRyYWwgY3Jvc3MgaW50ZXJzZWN0aW9uIGFyZWFcclxuICAgICAgICAgICAgbGV0IHRhcmdldFggPSA0MDA7XHJcbiAgICAgICAgICAgIGxldCB0YXJnZXRZID0gNDAwO1xyXG5cclxuICAgICAgICAgICAgaWYgKGhhbGwgPT09IDEpIHsgdGFyZ2V0WCA9IDM3MDsgdGFyZ2V0WSA9IDM3MDsgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChoYWxsID09PSAyKSB7IHRhcmdldFggPSA0MzA7IHRhcmdldFkgPSAzNzA7IH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoaGFsbCA9PT0gMykgeyB0YXJnZXRYID0gMzcwOyB0YXJnZXRZID0gNDMwOyB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGhhbGwgPT09IDQpIHsgdGFyZ2V0WCA9IDQzMDsgdGFyZ2V0WSA9IDQzMDsgfVxyXG5cclxuICAgICAgICAgICAgLy8gTW92ZSB0b3dhcmRzIHRhcmdldFxyXG4gICAgICAgICAgICBjb25zdCBkeCA9IHRhcmdldFggLSB4O1xyXG4gICAgICAgICAgICBjb25zdCBkeSA9IHRhcmdldFkgLSB5O1xyXG4gICAgICAgICAgICBjb25zdCBkaXN0ID0gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcclxuXHJcbiAgICAgICAgICAgIGlmIChkaXN0IDwgMTApIHtcclxuICAgICAgICAgICAgICAgIHN0YXR1cyA9ICdtZXJnaW5nJztcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHZ4ID0gKGR4IC8gZGlzdCkgKiBzcGVlZDtcclxuICAgICAgICAgICAgICAgIHZ5ID0gKGR5IC8gZGlzdCkgKiBzcGVlZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChzdGF0dXMgPT09ICdtZXJnaW5nJykge1xyXG4gICAgICAgICAgICAvLyBNb3ZlIHRvIGNlbnRlciBvZiBjb3JyaWRvciBsYW5lc1xyXG4gICAgICAgICAgICBjb25zdCB0YXJnZXRYID0gNDAwO1xyXG4gICAgICAgICAgICBjb25zdCB0YXJnZXRZID0gNDAwO1xyXG4gICAgICAgICAgICBjb25zdCBkeCA9IHRhcmdldFggLSB4O1xyXG4gICAgICAgICAgICBjb25zdCBkeSA9IHRhcmdldFkgLSB5O1xyXG4gICAgICAgICAgICBjb25zdCBkaXN0ID0gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcclxuXHJcbiAgICAgICAgICAgIGlmIChkaXN0IDwgNSkge1xyXG4gICAgICAgICAgICAgICAgc3RhdHVzID0gJ2luX2xhbmUnO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdnggPSAoZHggLyBkaXN0KSAqIHNwZWVkO1xyXG4gICAgICAgICAgICAgICAgdnkgPSAoZHkgLyBkaXN0KSAqIHNwZWVkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHN0YXR1cyA9PT0gJ2luX2xhbmUnKSB7XHJcbiAgICAgICAgICAgIC8vIE1vdmUgYWxvbmcgdGhlIG1haW4gYXhlcyB0b3dhcmRzIHRhcmdldCBleGl0XHJcbiAgICAgICAgICAgIC8vIEV4aXQgMSAoVG9wKTogeD0zODAuLjQyMCwgeSAtPiAwXHJcbiAgICAgICAgICAgIC8vIEV4aXQgMiAoUmlnaHQpOiB5PTM4MC4uNDIwLCB4IC0+IDgwMFxyXG4gICAgICAgICAgICAvLyBFeGl0IDMgKEJvdHRvbSk6IHg9MzgwLi40MjAsIHkgLT4gODAwXHJcbiAgICAgICAgICAgIC8vIEV4aXQgNCAoTGVmdCk6IHk9MzgwLi40MjAsIHggLT4gMFxyXG5cclxuICAgICAgICAgICAgaWYgKHRhcmdldEV4aXQgPT09IDEpIHsgLy8gVG9wXHJcbiAgICAgICAgICAgICAgICBpZiAoTWF0aC5hYnMoeCAtIDQwMCkgPiAxNSkgeyAvLyBDZW50ZXIgWCBmaXJzdFxyXG4gICAgICAgICAgICAgICAgICAgIHZ4ID0gKDQwMCAtIHgpICogMC4xO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB2eSA9IC1zcGVlZCAqIDEuNTsgLy8gTW92ZSBVcFxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHkgPCA1MCkgc3RhdHVzID0gJ2F0X2V4aXQnO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHRhcmdldEV4aXQgPT09IDIpIHsgLy8gUmlnaHRcclxuICAgICAgICAgICAgICAgIGlmIChNYXRoLmFicyh5IC0gNDAwKSA+IDE1KSB7IC8vIENlbnRlciBZIGZpcnN0XHJcbiAgICAgICAgICAgICAgICAgICAgdnkgPSAoNDAwIC0geSkgKiAwLjE7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHZ4ID0gc3BlZWQgKiAxLjU7IC8vIE1vdmUgUmlnaHRcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICh4ID4gNzUwKSBzdGF0dXMgPSAnYXRfZXhpdCc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodGFyZ2V0RXhpdCA9PT0gMykgeyAvLyBCb3R0b21cclxuICAgICAgICAgICAgICAgIGlmIChNYXRoLmFicyh4IC0gNDAwKSA+IDE1KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdnggPSAoNDAwIC0geCkgKiAwLjE7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHZ5ID0gc3BlZWQgKiAxLjU7IC8vIE1vdmUgRG93blxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHkgPiA3NTApIHN0YXR1cyA9ICdhdF9leGl0JztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICh0YXJnZXRFeGl0ID09PSA0KSB7IC8vIExlZnRcclxuICAgICAgICAgICAgICAgIGlmIChNYXRoLmFicyh5IC0gNDAwKSA+IDE1KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdnkgPSAoNDAwIC0geSkgKiAwLjE7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHZ4ID0gLXNwZWVkICogMS41OyAvLyBNb3ZlIExlZnRcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICh4IDwgNTApIHN0YXR1cyA9ICdhdF9leGl0JztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChzdGF0dXMgPT09ICdhdF9leGl0Jykge1xyXG4gICAgICAgICAgICAvLyBDb25ncmVnYXRlIGFuZCBtb3ZlIHNsb3dseSBuZWFyIGV4aXRcclxuICAgICAgICAgICAgLy8gQWRkIHNvbWUgaml0dGVyIHRvIGxvb2sgbGlrZSBhIGNyb3dkXHJcbiAgICAgICAgICAgIHZ4ID0gKE1hdGgucmFuZG9tKCkgLSAwLjUpICogMC41O1xyXG4gICAgICAgICAgICB2eSA9IChNYXRoLnJhbmRvbSgpIC0gMC41KSAqIDAuNTtcclxuXHJcbiAgICAgICAgICAgIC8vIEtlZXAgd2l0aGluIGV4aXQgem9uZVxyXG4gICAgICAgICAgICBpZiAodGFyZ2V0RXhpdCA9PT0gMSkgeyAvLyBUb3BcclxuICAgICAgICAgICAgICAgIGlmICh5ID4gNjApIHZ5IC09IDAuMjtcclxuICAgICAgICAgICAgICAgIGlmICh5IDwgMTApIHZ5ICs9IDAuMjtcclxuICAgICAgICAgICAgICAgIGlmICh4IDwgMzYwKSB2eCArPSAwLjI7XHJcbiAgICAgICAgICAgICAgICBpZiAoeCA+IDQ0MCkgdnggLT0gMC4yO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHRhcmdldEV4aXQgPT09IDIpIHsgLy8gUmlnaHRcclxuICAgICAgICAgICAgICAgIGlmICh4IDwgNzQwKSB2eCArPSAwLjI7XHJcbiAgICAgICAgICAgICAgICBpZiAoeCA+IDc5MCkgdnggLT0gMC4yO1xyXG4gICAgICAgICAgICAgICAgaWYgKHkgPCAzNjApIHZ5ICs9IDAuMjtcclxuICAgICAgICAgICAgICAgIGlmICh5ID4gNDQwKSB2eSAtPSAwLjI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodGFyZ2V0RXhpdCA9PT0gMykgeyAvLyBCb3R0b21cclxuICAgICAgICAgICAgICAgIGlmICh5IDwgNzQwKSB2eSArPSAwLjI7XHJcbiAgICAgICAgICAgICAgICBpZiAoeSA+IDc5MCkgdnkgLT0gMC4yO1xyXG4gICAgICAgICAgICAgICAgaWYgKHggPCAzNjApIHZ4ICs9IDAuMjtcclxuICAgICAgICAgICAgICAgIGlmICh4ID4gNDQwKSB2eCAtPSAwLjI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodGFyZ2V0RXhpdCA9PT0gNCkgeyAvLyBMZWZ0XHJcbiAgICAgICAgICAgICAgICBpZiAoeCA+IDYwKSB2eCAtPSAwLjI7XHJcbiAgICAgICAgICAgICAgICBpZiAoeCA8IDEwKSB2eCArPSAwLjI7XHJcbiAgICAgICAgICAgICAgICBpZiAoeSA8IDM2MCkgdnkgKz0gMC4yO1xyXG4gICAgICAgICAgICAgICAgaWYgKHkgPiA0NDApIHZ5IC09IDAuMjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gT2NjYXNpb25hbGx5IHJlc2V0IHRvIGhhbGwgdG8ga2VlcCBzaW11bGF0aW9uIGZsb3dpbmdcclxuICAgICAgICAgICAgaWYgKE1hdGgucmFuZG9tKCkgPCAwLjAwNSkge1xyXG4gICAgICAgICAgICAgICAgc3RhdHVzID0gJ2luX2hhbGwnO1xyXG4gICAgICAgICAgICAgICAgaGFsbCA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDQpICsgMTtcclxuICAgICAgICAgICAgICAgIHBlcnNvbi50YXJnZXRFeGl0ID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogNCkgKyAxOyAvLyBQaWNrIG5ldyB0YXJnZXRcclxuICAgICAgICAgICAgICAgIC8vIFJlc2V0IHBvc1xyXG4gICAgICAgICAgICAgICAgaWYgKGhhbGwgPT09IDEpIHsgeCA9IDIwMDsgeSA9IDIwMDsgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaGFsbCA9PT0gMikgeyB4ID0gNjAwOyB5ID0gMjAwOyB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChoYWxsID09PSAzKSB7IHggPSAyMDA7IHkgPSA2MDA7IH1cclxuICAgICAgICAgICAgICAgIGVsc2UgeyB4ID0gNjAwOyB5ID0gNjAwOyB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEFwcGx5IG1vdmVtZW50XHJcbiAgICAgICAgbGV0IG5ld1ggPSB4ICsgdng7XHJcbiAgICAgICAgbGV0IG5ld1kgPSB5ICsgdnk7XHJcblxyXG4gICAgICAgIC8vIEhhcmQgYm91bmRhcmllcyBmb3IgbWFwXHJcbiAgICAgICAgbmV3WCA9IE1hdGgubWF4KDAsIE1hdGgubWluKDgwMCwgbmV3WCkpO1xyXG4gICAgICAgIG5ld1kgPSBNYXRoLm1heCgwLCBNYXRoLm1pbig4MDAsIG5ld1kpKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgLi4ucGVyc29uLFxyXG4gICAgICAgICAgICB4OiBuZXdYLFxyXG4gICAgICAgICAgICB5OiBuZXdZLFxyXG4gICAgICAgICAgICB2eCxcclxuICAgICAgICAgICAgdnksXHJcbiAgICAgICAgICAgIHN0YXR1cyxcclxuICAgICAgICAgICAgaGFsbFxyXG4gICAgICAgIH07XHJcbiAgICB9KTtcclxufVxyXG5cclxuLy8gR2VuZXJhdGUgZHluYW1pYyByb3V0aW5nIGFsZXJ0c1xyXG5leHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGVSb3V0aW5nQWxlcnQoZ2F0ZXM6IEdhdGVbXSwgaGFsbHM6IEhhbGxbXSk6IEFsZXJ0IHwgbnVsbCB7XHJcbiAgICBjb25zdCBiZXN0R2F0ZSA9IGdhdGVzLnJlZHVjZSgoYmVzdCwgY3VycmVudCkgPT5cclxuICAgICAgICBjdXJyZW50Lm1ldHJpY3Mud2FpdF90aW1lX3NlY29uZHMgPCBiZXN0Lm1ldHJpY3Mud2FpdF90aW1lX3NlY29uZHMgPyBjdXJyZW50IDogYmVzdFxyXG4gICAgKTtcclxuXHJcbiAgICBjb25zdCB3b3JzdEdhdGUgPSBnYXRlcy5yZWR1Y2UoKHdvcnN0LCBjdXJyZW50KSA9PlxyXG4gICAgICAgIGN1cnJlbnQubWV0cmljcy53YWl0X3RpbWVfc2Vjb25kcyA+IHdvcnN0Lm1ldHJpY3Mud2FpdF90aW1lX3NlY29uZHMgPyBjdXJyZW50IDogd29yc3RcclxuICAgICk7XHJcblxyXG4gICAgLy8gQ2hlY2sgZm9yIGhpZ2gtcmlzayBoYWxsc1xyXG4gICAgY29uc3QgaGlnaFJpc2tIYWxscyA9IGhhbGxzLmZpbHRlcihoID0+IGguc3RhbXBlZGVfcmlzayA9PT0gJ2hpZ2gnIHx8IGguc3RhbXBlZGVfcmlzayA9PT0gJ2NyaXRpY2FsJyk7XHJcblxyXG4gICAgaWYgKGhpZ2hSaXNrSGFsbHMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGlkOiBgYWxlcnQtJHtEYXRlLm5vdygpfWAsXHJcbiAgICAgICAgICAgIHR5cGU6ICdzdGFtcGVkZScsXHJcbiAgICAgICAgICAgIHNldmVyaXR5OiAnY3JpdGljYWwnLFxyXG4gICAgICAgICAgICBtZXNzYWdlOiBg4pqg77iPIEhpZ2ggc3RhbXBlZGUgcmlzayBpbiAke2hpZ2hSaXNrSGFsbHMubWFwKGggPT4gaC5uYW1lKS5qb2luKCcsICcpfSEgQXZvaWQgdGhlc2UgYXJlYXMuYCxcclxuICAgICAgICAgICAgc3VnZ2VzdGVkRXhpdDogYmVzdEdhdGUuZ2F0ZV9udW1iZXIsXHJcbiAgICAgICAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKSxcclxuICAgICAgICAgICAgYWN0aXZlOiB0cnVlLFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHdvcnN0R2F0ZS5jcm93ZF9sZXZlbCA9PT0gJ2NyaXRpY2FsJyAmJiBiZXN0R2F0ZS5jcm93ZF9sZXZlbCA9PT0gJ2xvdycpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBpZDogYGFsZXJ0LSR7RGF0ZS5ub3coKX1gLFxyXG4gICAgICAgICAgICB0eXBlOiAncm91dGluZycsXHJcbiAgICAgICAgICAgIHNldmVyaXR5OiAnaGlnaCcsXHJcbiAgICAgICAgICAgIG1lc3NhZ2U6IGDwn5qoIEV4aXQgJHt3b3JzdEdhdGUuZ2F0ZV9udW1iZXJ9IGlzIG92ZXJjcm93ZGVkISBVc2UgRXhpdCAke2Jlc3RHYXRlLmdhdGVfbnVtYmVyfSBpbnN0ZWFkICgke2Jlc3RHYXRlLm1ldHJpY3Mud2FpdF90aW1lX2Zvcm1hdHRlZH0gd2FpdCkuYCxcclxuICAgICAgICAgICAgc3VnZ2VzdGVkRXhpdDogYmVzdEdhdGUuZ2F0ZV9udW1iZXIsXHJcbiAgICAgICAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKSxcclxuICAgICAgICAgICAgYWN0aXZlOiB0cnVlLFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHdvcnN0R2F0ZS5jcm93ZF9sZXZlbCA9PT0gJ2hpZ2gnICYmIGJlc3RHYXRlLmNyb3dkX2xldmVsID09PSAnbG93Jykge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGlkOiBgYWxlcnQtJHtEYXRlLm5vdygpfWAsXHJcbiAgICAgICAgICAgIHR5cGU6ICdyb3V0aW5nJyxcclxuICAgICAgICAgICAgc2V2ZXJpdHk6ICdtZWRpdW0nLFxyXG4gICAgICAgICAgICBtZXNzYWdlOiBg8J+SoSBFeGl0ICR7YmVzdEdhdGUuZ2F0ZV9udW1iZXJ9IGhhcyB0aGUgc2hvcnRlc3Qgd2FpdCB0aW1lICgke2Jlc3RHYXRlLm1ldHJpY3Mud2FpdF90aW1lX2Zvcm1hdHRlZH0pLmAsXHJcbiAgICAgICAgICAgIHN1Z2dlc3RlZEV4aXQ6IGJlc3RHYXRlLmdhdGVfbnVtYmVyLFxyXG4gICAgICAgICAgICB0aW1lc3RhbXA6IERhdGUubm93KCksXHJcbiAgICAgICAgICAgIGFjdGl2ZTogdHJ1ZSxcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBudWxsO1xyXG59XHJcblxyXG5mdW5jdGlvbiBjcmVhdGVHYXRlKGdhdGVOdW1iZXI6IG51bWJlciwgY29vcmRpbmF0ZXM6IHN0cmluZywgY291bnQ6IG51bWJlcik6IEdhdGUge1xyXG4gICAgY29uc3QgW2xhdCwgbG9uXSA9IGNvb3JkaW5hdGVzLnNwbGl0KCcsJykubWFwKE51bWJlcik7XHJcblxyXG4gICAgLy8gRGV0ZXJtaW5lIGNyb3dkIGxldmVsXHJcbiAgICBsZXQgY3Jvd2RMZXZlbDogJ2xvdycgfCAnbWVkaXVtJyB8ICdoaWdoJyB8ICdjcml0aWNhbCc7XHJcbiAgICBsZXQgY3Jvd2RDb2xvcjogc3RyaW5nO1xyXG5cclxuICAgIGlmIChjb3VudCA8IDgwKSB7XHJcbiAgICAgICAgY3Jvd2RMZXZlbCA9ICdsb3cnO1xyXG4gICAgICAgIGNyb3dkQ29sb3IgPSAnIzEwYjk4MSc7XHJcbiAgICB9IGVsc2UgaWYgKGNvdW50IDwgMTUwKSB7XHJcbiAgICAgICAgY3Jvd2RMZXZlbCA9ICdtZWRpdW0nO1xyXG4gICAgICAgIGNyb3dkQ29sb3IgPSAnI2Y1OWUwYic7XHJcbiAgICB9IGVsc2UgaWYgKGNvdW50IDwgMjIwKSB7XHJcbiAgICAgICAgY3Jvd2RMZXZlbCA9ICdoaWdoJztcclxuICAgICAgICBjcm93ZENvbG9yID0gJyNmOTczMTYnO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBjcm93ZExldmVsID0gJ2NyaXRpY2FsJztcclxuICAgICAgICBjcm93ZENvbG9yID0gJyNlZjQ0NDQnO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIENhbGN1bGF0ZSBtZXRyaWNzXHJcbiAgICBjb25zdCBkZW5zaXR5ID0gY291bnQgLyAyMDA7XHJcbiAgICBjb25zdCB3YWl0VGltZSA9IE1hdGgubWF4KDMwLCBjb3VudCAqIDIpO1xyXG4gICAgY29uc3QgcXVldWVMZW5ndGggPSBjb3VudCAqIDAuMDg7XHJcblxyXG4gICAgLy8gR2VuZXJhdGUgdHJlbmRcclxuICAgIGNvbnN0IHNwYXJrbGluZSA9IGdlbmVyYXRlU3BhcmtsaW5lKGNvdW50KTtcclxuICAgIGNvbnN0IHRyZW5kID0gZGV0ZXJtaW5lVHJlbmQoc3BhcmtsaW5lKTtcclxuXHJcbiAgICAvLyBHYXRlIG5hbWVzXHJcbiAgICBjb25zdCBnYXRlTmFtZXMgPSBbJ05vcnRoIEV4aXQgKEV4aXQgMSknLCAnRWFzdCBFeGl0IChFeGl0IDIpJywgJ1NvdXRoIEV4aXQgKEV4aXQgMyknLCAnV2VzdCBFeGl0IChFeGl0IDQpJ107XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBpZDogYGdhdGUtJHtnYXRlTnVtYmVyfWAsXHJcbiAgICAgICAgZ2F0ZV9udW1iZXI6IGdhdGVOdW1iZXIsXHJcbiAgICAgICAgbmFtZTogZ2F0ZU5hbWVzW2dhdGVOdW1iZXIgLSAxXSxcclxuICAgICAgICBsb2NhdGlvbjogeyBsYXQsIGxvbiB9LFxyXG4gICAgICAgIHN0YXR1czogJ2FjdGl2ZScsXHJcbiAgICAgICAgY3Jvd2RfbGV2ZWw6IGNyb3dkTGV2ZWwsXHJcbiAgICAgICAgY3Jvd2RfY29sb3I6IGNyb3dkQ29sb3IsXHJcbiAgICAgICAgbWV0cmljczoge1xyXG4gICAgICAgICAgICBwZW9wbGVfY291bnQ6IGNvdW50LFxyXG4gICAgICAgICAgICBkZW5zaXR5OiBwYXJzZUZsb2F0KGRlbnNpdHkudG9GaXhlZCgyKSksXHJcbiAgICAgICAgICAgIGRlbnNpdHlfbGV2ZWw6IGNyb3dkTGV2ZWwsXHJcbiAgICAgICAgICAgIHdhaXRfdGltZV9zZWNvbmRzOiB3YWl0VGltZSxcclxuICAgICAgICAgICAgd2FpdF90aW1lX2Zvcm1hdHRlZDogZm9ybWF0V2FpdFRpbWUod2FpdFRpbWUpLFxyXG4gICAgICAgICAgICBxdWV1ZV9sZW5ndGhfbWV0ZXJzOiBwYXJzZUZsb2F0KHF1ZXVlTGVuZ3RoLnRvRml4ZWQoMSkpLFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgdHJlbmQsXHJcbiAgICAgICAgcHJlZGljdGlvbjoge1xyXG4gICAgICAgICAgICAnNV9taW5fYWhlYWQnOiB7XHJcbiAgICAgICAgICAgICAgICBjb3VudDogTWF0aC5yb3VuZChjb3VudCAqICgxICsgKE1hdGgucmFuZG9tKCkgLSAwLjQpICogMC4yKSksXHJcbiAgICAgICAgICAgICAgICBjb25maWRlbmNlOiAwLjg1ICsgTWF0aC5yYW5kb20oKSAqIDAuMSxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgJzEwX21pbl9haGVhZCc6IHtcclxuICAgICAgICAgICAgICAgIGNvdW50OiBNYXRoLnJvdW5kKGNvdW50ICogKDEgKyAoTWF0aC5yYW5kb20oKSAtIDAuNCkgKiAwLjMpKSxcclxuICAgICAgICAgICAgICAgIGNvbmZpZGVuY2U6IDAuNzUgKyBNYXRoLnJhbmRvbSgpICogMC4xLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgaGFzX2FjY2Vzc2liaWxpdHk6IGdhdGVOdW1iZXIgPT09IDEgfHwgZ2F0ZU51bWJlciA9PT0gMyxcclxuICAgICAgICBlZmZpY2llbmN5X3BlcmNlbnQ6IE1hdGgucm91bmQoNzAgKyBNYXRoLnJhbmRvbSgpICogMjUpLFxyXG4gICAgfTtcclxufVxyXG5cclxuZnVuY3Rpb24gZ2VuZXJhdGVTcGFya2xpbmUoY3VycmVudENvdW50OiBudW1iZXIpOiBudW1iZXJbXSB7XHJcbiAgICBjb25zdCBwb2ludHMgPSAxMDtcclxuICAgIGNvbnN0IHNwYXJrbGluZTogbnVtYmVyW10gPSBbXTtcclxuICAgIGxldCB2YWx1ZSA9IGN1cnJlbnRDb3VudCAtIDIwO1xyXG5cclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcG9pbnRzOyBpKyspIHtcclxuICAgICAgICB2YWx1ZSArPSAoTWF0aC5yYW5kb20oKSAtIDAuNSkgKiAxMDtcclxuICAgICAgICB2YWx1ZSA9IE1hdGgubWF4KDIwLCBNYXRoLm1pbigzMDAsIHZhbHVlKSk7XHJcbiAgICAgICAgc3BhcmtsaW5lLnB1c2goTWF0aC5yb3VuZCh2YWx1ZSkpO1xyXG4gICAgfVxyXG5cclxuICAgIHNwYXJrbGluZVtzcGFya2xpbmUubGVuZ3RoIC0gMV0gPSBjdXJyZW50Q291bnQ7XHJcbiAgICByZXR1cm4gc3BhcmtsaW5lO1xyXG59XHJcblxyXG5mdW5jdGlvbiBkZXRlcm1pbmVUcmVuZChzcGFya2xpbmU6IG51bWJlcltdKToge1xyXG4gICAgZGlyZWN0aW9uOiAnaW5jcmVhc2luZycgfCAnc3RhYmxlJyB8ICdkZWNyZWFzaW5nJztcclxuICAgIGNoYW5nZV9wZXJjZW50OiBudW1iZXI7XHJcbn0ge1xyXG4gICAgY29uc3QgZmlyc3QgPSBzcGFya2xpbmVbMF07XHJcbiAgICBjb25zdCBsYXN0ID0gc3BhcmtsaW5lW3NwYXJrbGluZS5sZW5ndGggLSAxXTtcclxuICAgIGNvbnN0IGNoYW5nZSA9ICgobGFzdCAtIGZpcnN0KSAvIGZpcnN0KSAqIDEwMDtcclxuXHJcbiAgICBsZXQgZGlyZWN0aW9uOiAnaW5jcmVhc2luZycgfCAnc3RhYmxlJyB8ICdkZWNyZWFzaW5nJztcclxuICAgIGlmIChjaGFuZ2UgPiAxMCkge1xyXG4gICAgICAgIGRpcmVjdGlvbiA9ICdpbmNyZWFzaW5nJztcclxuICAgIH0gZWxzZSBpZiAoY2hhbmdlIDwgLTEwKSB7XHJcbiAgICAgICAgZGlyZWN0aW9uID0gJ2RlY3JlYXNpbmcnO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBkaXJlY3Rpb24gPSAnc3RhYmxlJztcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGRpcmVjdGlvbixcclxuICAgICAgICBjaGFuZ2VfcGVyY2VudDogcGFyc2VGbG9hdChNYXRoLmFicyhjaGFuZ2UpLnRvRml4ZWQoMSkpLFxyXG4gICAgfTtcclxufVxyXG5cclxuZnVuY3Rpb24gZm9ybWF0V2FpdFRpbWUoc2Vjb25kczogbnVtYmVyKTogc3RyaW5nIHtcclxuICAgIGNvbnN0IG1pbnV0ZXMgPSBNYXRoLnJvdW5kKHNlY29uZHMgLyA2MCk7XHJcbiAgICBpZiAobWludXRlcyA9PT0gMCkgcmV0dXJuICc8MSBtaW51dGUnO1xyXG4gICAgaWYgKG1pbnV0ZXMgPT09IDEpIHJldHVybiAnMSBtaW51dGUnO1xyXG4gICAgcmV0dXJuIGAke21pbnV0ZXN9IG1pbnV0ZXNgO1xyXG59XHJcbiJdLCJuYW1lcyI6WyJzaW11bGF0ZUNyb3dkRGF0YSIsImJhc2VUaW1lIiwiRGF0ZSIsIm5vdyIsInZhcmlhdGlvbjEiLCJNYXRoIiwic2luIiwicmFuZG9tIiwidmFyaWF0aW9uMiIsImNvcyIsInZhcmlhdGlvbjMiLCJ2YXJpYXRpb240IiwiZ2F0ZXMiLCJjcmVhdGVHYXRlIiwicm91bmQiLCJzaW11bGF0ZUhhbGxEYXRhIiwiaGFsbHMiLCJjcmVhdGVIYWxsIiwiaGFsbE51bWJlciIsImNvdW50IiwiY2FwYWNpdHkiLCJkZW5zaXR5UGVyY2VudCIsImNyb3dkTGV2ZWwiLCJoZWF0bWFwQ29sb3IiLCJzdGFtcGVkZV9yaXNrIiwiaWQiLCJudW1iZXIiLCJuYW1lIiwiY3VycmVudF9jb3VudCIsImRlbnNpdHlfcGVyY2VudCIsInBhcnNlRmxvYXQiLCJ0b0ZpeGVkIiwiY3Jvd2RfbGV2ZWwiLCJoZWF0bWFwX2NvbG9yIiwiaW5pdGlhbGl6ZUNyb3dkU2ltdWxhdGlvbiIsImhhbGxDb3VudCIsInBlb3BsZSIsInRvdGFsUGVvcGxlIiwiaSIsImhhbGwiLCJmbG9vciIsInRhcmdldEV4aXQiLCJ4IiwieSIsInB1c2giLCJ2eCIsInZ5Iiwic3BlZWQiLCJzdGF0dXMiLCJ1cGRhdGVDcm93ZFBvc2l0aW9ucyIsIm1hcCIsInBlcnNvbiIsInRhcmdldFgiLCJ0YXJnZXRZIiwiZHgiLCJkeSIsImRpc3QiLCJzcXJ0IiwiYWJzIiwibmV3WCIsIm5ld1kiLCJtYXgiLCJtaW4iLCJnZW5lcmF0ZVJvdXRpbmdBbGVydCIsImJlc3RHYXRlIiwicmVkdWNlIiwiYmVzdCIsImN1cnJlbnQiLCJtZXRyaWNzIiwid2FpdF90aW1lX3NlY29uZHMiLCJ3b3JzdEdhdGUiLCJ3b3JzdCIsImhpZ2hSaXNrSGFsbHMiLCJmaWx0ZXIiLCJoIiwibGVuZ3RoIiwidHlwZSIsInNldmVyaXR5IiwibWVzc2FnZSIsImpvaW4iLCJzdWdnZXN0ZWRFeGl0IiwiZ2F0ZV9udW1iZXIiLCJ0aW1lc3RhbXAiLCJhY3RpdmUiLCJ3YWl0X3RpbWVfZm9ybWF0dGVkIiwiZ2F0ZU51bWJlciIsImNvb3JkaW5hdGVzIiwibGF0IiwibG9uIiwic3BsaXQiLCJOdW1iZXIiLCJjcm93ZENvbG9yIiwiZGVuc2l0eSIsIndhaXRUaW1lIiwicXVldWVMZW5ndGgiLCJzcGFya2xpbmUiLCJnZW5lcmF0ZVNwYXJrbGluZSIsInRyZW5kIiwiZGV0ZXJtaW5lVHJlbmQiLCJnYXRlTmFtZXMiLCJsb2NhdGlvbiIsImNyb3dkX2NvbG9yIiwicGVvcGxlX2NvdW50IiwiZGVuc2l0eV9sZXZlbCIsImZvcm1hdFdhaXRUaW1lIiwicXVldWVfbGVuZ3RoX21ldGVycyIsInByZWRpY3Rpb24iLCJjb25maWRlbmNlIiwiaGFzX2FjY2Vzc2liaWxpdHkiLCJlZmZpY2llbmN5X3BlcmNlbnQiLCJjdXJyZW50Q291bnQiLCJwb2ludHMiLCJ2YWx1ZSIsImZpcnN0IiwibGFzdCIsImNoYW5nZSIsImRpcmVjdGlvbiIsImNoYW5nZV9wZXJjZW50Iiwic2Vjb25kcyIsIm1pbnV0ZXMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/mockData.ts\n"));

/***/ })

});